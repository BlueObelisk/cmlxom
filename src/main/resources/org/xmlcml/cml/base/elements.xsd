<?xml version="1.0" encoding="UTF-8"?>
<!--

       Copyright 2011 Peter Murray-Rust et. al.

       Licensed under the Apache License, Version 2.0 (the "License");
       you may not use this file except in compliance with the License.
       You may obtain a copy of the License at

           http://www.apache.org/licenses/LICENSE-2.0

       Unless required by applicable law or agreed to in writing, software
       distributed under the License is distributed on an "AS IS" BASIS,
       WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       See the License for the specific language governing permissions and
       limitations under the License.

-->

<schema xmlns="http://www.w3.org/2001/XMLSchema">
 <xsd:element name="abundance" id="el.abundance" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">The abundance of an isotope.</h:div>
    <h:div class="description">The abundance of an isotope in an isotopeList. Values are expressed in percentages.</h:div>
    <h:div class="example" href="isotope1.xml"/>
   </xsd:documentation>
  </xsd:annotation>
  <xsd:complexType>
   <xsd:simpleContent>
    <xsd:extension base="xsd:double">
     <xsd:attributeGroup ref="title"/>
     <xsd:attributeGroup ref="id"/>
     <xsd:attributeGroup ref="convention"/>
     <xsd:attributeGroup ref="dictRef"/>
     <xsd:attributeGroup ref="min"/>
     <xsd:attributeGroup ref="max"/>
     <xsd:attributeGroup ref="units"/>
    </xsd:extension>
   </xsd:simpleContent>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="action" id="el.action" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">An action which might occur in scientific data or narrative.</h:div>
    <h:div class="description"> An action which might occur in scientific data or narrative. The definition is deliberately vague, intending to collect examples of possible usage. Thus an action could be addition of materials, measurement, application of heat or radiation. The content model is unrestricted. _action_ iself is normally a child of _actionList_. 
     <h:p>The start, end and duration attributes should be interpreted as </h:p>
     <h:ul>
      <h:li>XSD dateTimes and XSD durations. This allows precise recording of time of day, etc, or duration after start of actionList. A 
       <h:tt>convention="xsd"</h:tt> attribute should be used to enforce XSD.
      </h:li>
      <h:li>a numerical value, with a units attribute linked to a dictionary.</h:li>
      <h:li>a human-readable string (unlikely to be machine processable)</h:li>
     </h:ul>
     <h:p>
      <h:tt>startCondition</h:tt> and 
      <h:tt>endCondition</h:tt> values are not constrained, which allows XSL-like 
      <h:tt>test</h:tt> attribute values. The semantics of the conditions are yet to be defined and at present are simply human readable. 
     </h:p>
     <h:p>The order of the 
      <h:tt>action</h:tt> elements in the document may, but will not always, define the order that they actually occur in.
     </h:p>
     <h:p>A delay can be shown by an 
      <h:tt>action</h:tt> with no content. Repeated actions or actionLists are indicated through the count attribute.
     </h:p>
    </h:div>
    <h:div class="example" href="action1.xml"/>
    <!-- <h:div class="example" href="action2.xml"></h:div> -->
   </xsd:documentation>
  </xsd:annotation>
  <xsd:complexType mixed="true">
   <xsd:sequence minOccurs="0" maxOccurs="unbounded">
    <xsd:any processContents="lax"/>
   </xsd:sequence>
   <xsd:attributeGroup ref="title"/>
   <xsd:attributeGroup ref="id"/>
   <xsd:attributeGroup ref="convention"/>
   <xsd:attributeGroup ref="dictRef"/>
   <xsd:attributeGroup ref="units"/>
   <xsd:attributeGroup ref="start"/>
   <xsd:attributeGroup ref="startCondition"/>
   <xsd:attributeGroup ref="duration"/>
   <xsd:attributeGroup ref="end"/>
   <xsd:attributeGroup ref="endCondition"/>
   <xsd:attributeGroup ref="type"/>
   <xsd:attributeGroup ref="actionOrder"/>
   <xsd:attributeGroup ref="count">
    <xsd:annotation>
     <xsd:documentation>
      <h:div class="specific">Number of times the action should be repeated.</h:div>
     </xsd:documentation>
    </xsd:annotation>
   </xsd:attributeGroup>
   <xsd:attributeGroup ref="ref"/>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="actionList" id="el.actionList" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">A container for a group of actions.</h:div>
    <h:div class="description">
     <h:tt>ActionList</h:tt> contains a series of
     <h:tt>action</h:tt>s or nested
     <h:tt>actionList</h:tt>s.
    </h:div>
    <h:div class="example" href="actionList1.xml"/>
   </xsd:documentation>
  </xsd:annotation>
  <xsd:complexType mixed="true">
   <xsd:sequence minOccurs="0" maxOccurs="unbounded">
    <xsd:any processContents="lax"/>
   </xsd:sequence>
   <xsd:attributeGroup ref="title"/>
   <xsd:attributeGroup ref="id"/>
   <xsd:attributeGroup ref="convention"/>
   <xsd:attributeGroup ref="dictRef"/>
   <xsd:attributeGroup ref="start"/>
   <xsd:attributeGroup ref="startCondition"/>
   <xsd:attributeGroup ref="duration"/>
   <xsd:attributeGroup ref="end"/>
   <xsd:attributeGroup ref="endCondition"/>
   <xsd:attributeGroup ref="units"/>
   <xsd:attributeGroup ref="count"/>
   <xsd:attributeGroup ref="type"/>
   <xsd:attributeGroup ref="actionOrder"/>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="alternative" id="el.alternative" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">An alternative name for an entry.</h:div>
    <h:div class="description"> At present a child of _entry_ which represents an alternative string that refers to the concept. There is a partial controlled vocabulary in _alternativeType_ with values such as : 
     <h:ul>
      <h:li>synonym</h:li>
      <h:li>acronym</h:li>
      <h:li>abbreviation</h:li>
     </h:ul>
    </h:div>
    <h:div class="example" href="alternative1.xml"/>
   </xsd:documentation>
  </xsd:annotation>
  <xsd:complexType>
   <xsd:simpleContent>
    <xsd:extension base="xsd:string">
     <xsd:attributeGroup ref="id"/>
     <xsd:attributeGroup ref="convention"/>
     <xsd:attributeGroup ref="alternativeType"/>
    </xsd:extension>
   </xsd:simpleContent>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="amount" id="el.amount" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">The amount of a substance.</h:div>
    <h:div class="description">The 
     <h:tt>units</h:tt> attribute is mandatory and can be customised to support mass, volumes, moles, percentages, or ratios (e.g. ppm).
    </h:div>
    <h:div class="example" href="amount1.xml"/>
   </xsd:documentation>
  </xsd:annotation>
  <xsd:complexType>
   <xsd:simpleContent>
    <xsd:extension base="xsd:double">
     <xsd:attributeGroup ref="title"/>
     <xsd:attributeGroup ref="id"/>
     <xsd:attributeGroup ref="convention"/>
     <xsd:attributeGroup ref="dictRef"/>
     <xsd:attributeGroup ref="units" id="att.amount.units"/>
    </xsd:extension>
   </xsd:simpleContent>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="angle" id="el.angle" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">An angle between three atoms.</h:div>
    <h:div class="description">
     <h:p>It can be used for:</h:p>
     <h:ul>
      <h:li>Recording experimentally determined bond angles (e.g. in a crystallographic paper).</h:li>
      <h:li>Providing the angle component for internal coordinates (e.g. z-matrix).</h:li>
     </h:ul>
    </h:div>
    <h:div class="example" href="angle1.xml"/>
   </xsd:documentation>
  </xsd:annotation>
  <xsd:complexType>
   <xsd:simpleContent>
    <xsd:extension base="nonNegativeAngleType">
     <xsd:attributeGroup ref="title"/>
     <xsd:attributeGroup ref="id"/>
     <xsd:attributeGroup ref="convention"/>
     <xsd:attributeGroup ref="dictRef"/>
     <xsd:attributeGroup ref="atomRefs3"/>
     <xsd:attributeGroup ref="angleUnits"/>
     <xsd:attributeGroup ref="errorValue"/>
     <xsd:attributeGroup ref="errorBasis"/>
     <xsd:attributeGroup ref="min"/>
     <xsd:attributeGroup ref="max"/>
     <xsd:attributeGroup ref="ref"/>
    </xsd:extension>
   </xsd:simpleContent>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="annotation" id="el.annotation" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">A documentation container similar to annotation in XML Schema.</h:div>
    <h:div class="description">A documentation container similar to 
     <h:tt>annotation</h:tt> in XML Schema. At present this is experimental and designed to be used for dictionaries, units, etc. One approach is to convert these into XML Schemas when the 
     <h:tt>documentation</h:tt> and 
     <h:tt>appinfo</h:tt> children will emerge in their correct position in the derived schema. 
     <h:p>It is possible that this may develop as a useful tool for annotating components of complex objects such as molecules. </h:p>
    </h:div>
    <h:div class="example" href="annotation1.xml"/>
   </xsd:documentation>
  </xsd:annotation>
  <xsd:complexType mixed="true">
   <xsd:choice minOccurs="0" maxOccurs="unbounded">
    <xsd:element ref="documentation"/>
    <xsd:element ref="appinfo"/>
   </xsd:choice>
   <xsd:attributeGroup ref="id"/>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="appinfo" id="el.appinfo" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">A container similar to appinfo in XML Schema.</h:div>
    <h:div class="description">A container for machine processable documentation for an entry. This is likely to be platform and/or language specific. It is possible that XSLT, RDF or XBL will emerge as generic languages. See _annotation_ and _documentation_ for further information.</h:div>
    <h:div class="example" href="appinfo1.xml">
     <h:p>An example in XSLT where an element _foo_ calls a bespoke template</h:p>.
    </h:div>
   </xsd:documentation>
  </xsd:annotation>
  <xsd:complexType mixed="true">
   <xsd:sequence minOccurs="0" maxOccurs="unbounded">
    <xsd:any processContents="lax"/>
   </xsd:sequence>
   <xsd:attributeGroup ref="role">
    <xsd:annotation>
     <xsd:documentation>
      <h:div class="specific">Allows a processor to inspect the role of the appinfo and process accordingly.</h:div>
     </xsd:documentation>
    </xsd:annotation>
   </xsd:attributeGroup>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="arg" id="el.arg" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">An argument for a function.</h:div>
    <h:div class="description">Arguments can be typed and have explicit or free values. They can also carry out substitutions in the parent element and its children (substitute, still experiemental) and delete itself after this.</h:div>
    <h:div class="curation">2006-02-14: PMR. Added atomType as child</h:div>
    <h:div class="curation">2006-05-21: PMR. Added substitute and delete attributes</h:div>
    <h:div class="example" href="potential1.xml"/>
   </xsd:documentation>
  </xsd:annotation>
  <xsd:complexType>
   <xsd:sequence>
    <xsd:choice minOccurs="0" maxOccurs="unbounded">
     <xsd:element ref="atom"/>
     <xsd:element ref="atomType"/>
     <xsd:element ref="scalar"/>
     <xsd:element ref="array"/>
     <xsd:element ref="matrix"/>
     <xsd:element ref="expression"/>
     <!-- Xerces doesn't let me do this <xsd:any processContents="lax"/> -->
    </xsd:choice>
   </xsd:sequence>
   <xsd:attributeGroup ref="title"/>
   <xsd:attributeGroup ref="id"/>
   <xsd:attributeGroup ref="convention"/>
   <xsd:attributeGroup ref="dictRef"/>
   <xsd:attributeGroup ref="ref"/>
   <xsd:attributeGroup ref="name"/>
   <xsd:attributeGroup ref="dataType"/>
   <xsd:attributeGroup ref="substitute"/>
   <xsd:attributeGroup ref="parameterName"/>
   <xsd:attributeGroup ref="parentAttribute"/>
   <xsd:attributeGroup ref="delete"/>
   <xsd:attributeGroup ref="eval"/>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="array" id="el.array" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">A homogenous 1 dimensional array of similar object.</h:div>
    <h:div class="description">These can be encoded as strings (i.e. XSD-like datatypes) and are concatenated as string content. The size of the array should always be &gt;= 1. The default delimiter is whitespace. The _normalize-space()_ function of XSLT could be used to normalize all whitespace to single spaces and this should not affect the value of the array elements. To extract the elements __java.lang.StringTokenizer__ could be used. If the elements themselves contain whitespace then a different delimiter must be used and is identified through the 
     <h:tt>delimiter</h:tt> attribute. This method is mandatory if it is required to represent empty strings. If a delimiter is used it MUST start and end the array - leading and trailing whitespace is ignored. Thus 
     <h:tt>size+1</h:tt> occurrences of the delimiter character are required. If non-normalized whitespace is to be encoded (e.g. newlines, tabs, etc) you are recommended to translate it character-wise to XML character entities. 
     <h:p>Note that normal Schema validation tools cannot validate the elements of 
      <h:b>array</h:b> (they are defined as 
      <h:tt>string</h:tt>) However if the string is split, a temporary schema can be constructed from the type and used for validation. Also the type can be contained in a dictionary and software could decide to retrieve this and use it for validation.
     </h:p>
     <h:p>When the elements of the 
      <h:tt>array</h:tt> are not simple scalars (e.g. 
      <h:a href="el.scalar">scalar</h:a>s with a value and an error, the 
      <h:tt>scalar</h:tt>s should be used as the elements. Although this is verbose, it is simple to understand. If there is a demand for more compact representations, it will be possible to define the syntax in a later version.
     </h:p>
    </h:div>
    <h:div class="example" href="array1.xml">
     <h:p>the 
      <h:tt>size</h:tt> attribute is not mandatory but provides a useful validity check): 
     </h:p>
    </h:div>
    <!-- <h:div class="example" href="array2.xml"> <h:p>Note that the second array-element is the empty string ''.</h:p></h:div> <h:div class="example" href="array3.xml"></h:div> -->
   </xsd:documentation>
  </xsd:annotation>
  <xsd:complexType>
   <xsd:simpleContent>
    <xsd:extension base="xsd:string">
     <xsd:attributeGroup ref="title"/>
     <xsd:attributeGroup ref="id"/>
     <xsd:attributeGroup ref="convention"/>
     <xsd:attributeGroup ref="dictRef"/>
     <xsd:attributeGroup ref="dataType"/>
     <xsd:attributeGroup ref="errorValueArray"/>
     <xsd:attributeGroup ref="errorBasis"/>
     <xsd:attributeGroup ref="minValueArray"/>
     <xsd:attributeGroup ref="maxValueArray"/>
     <xsd:attributeGroup ref="start"/>
     <xsd:attributeGroup ref="end"/>
     <xsd:attributeGroup ref="units"/>
     <xsd:attributeGroup ref="delimiter"/>
     <xsd:attributeGroup ref="size"/>
     <xsd:attributeGroup ref="ref"/>
     <xsd:attributeGroup ref="constantToSI">
      <xsd:annotation>
       <xsd:documentation>
        <h:div class="specific">Alternative to units</h:div>
        <h:div class="description">Must be used in conjunction with unitType</h:div>
        <h:div class="curation">2005-10-26: added</h:div>
       </xsd:documentation>
      </xsd:annotation>
     </xsd:attributeGroup>
     <xsd:attributeGroup ref="multiplierToSI">
      <xsd:annotation>
       <xsd:documentation>
        <h:div class="specific">Alternative to units</h:div>
        <h:div class="description">Must be used in conjunction with unitType</h:div>
        <h:div class="curation">2005-10-26: added</h:div>
       </xsd:documentation>
      </xsd:annotation>
     </xsd:attributeGroup>
     <xsd:attributeGroup ref="unitType">
      <xsd:annotation>
       <xsd:documentation>
        <h:div class="specific">Alternative to units</h:div>
        <h:div class="description">Must be used in conjunction with multiplierToSI and/or constantToSI</h:div>
        <h:div class="curation">2005-10-26: added</h:div>
       </xsd:documentation>
      </xsd:annotation>
     </xsd:attributeGroup>
    </xsd:extension>
   </xsd:simpleContent>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="arrayList" id="el.arrayList" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">A list of 
     <tt xmlns="">array</tt>s or 
     <tt xmlns="">list</tt>s.
    </h:div>
    <h:div class="description">
     <h:p>A major use of arrayList is to contain data within rectangular tables. However there is no absolute requirement and the table can have any shape. The 
      <tt xmlns="">shape</tt> attribute hould be used to assert rectangularity. 
     </h:p>
    </h:div>
    <h:div class="example" href="arrayList1.xml"/>
    <h:div class="curation">2006-11-03: created</h:div>
   </xsd:documentation>
  </xsd:annotation>
  <xsd:complexType>
   <xsd:choice minOccurs="0" maxOccurs="unbounded">
    <xsd:element ref="array"/>
    <xsd:element ref="list"/>
   </xsd:choice>
   <xsd:attributeGroup ref="shape"/>
   <xsd:attributeGroup ref="title"/>
   <xsd:attributeGroup ref="id"/>
   <xsd:attributeGroup ref="convention"/>
   <xsd:attributeGroup ref="dictRef"/>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="atom" id="el.atom" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">An atom.</h:div>
    <h:div documentation="general">Atoms can only be chosen from the periodic table and superatoms such as "Phe" or "Tyr" are not allowed. The elementType of an atom is identified by that attribute. There are two additional elementTypes, "Du" (for an object which does not have an identifiable nucleus but is useful in calculations and definitions (such as a centroid); and "R" which describes a generic fragment. Although atoms have an elementType, they do not, by default, support arbitrary atomTypes for which the &lt;atomType&gt; element should be used.</h:div>
    <h:div class="example" href="atom1.xml"/>
    <h:div class="curation">2006-01-12: PMR. Added vector3 child to support accelerations, velocities, dipole, etc.</h:div>
    <h:div class="curation">2006-06-01: PMR. Added documentation.</h:div>
   </xsd:documentation>
   <xsd:appinfo/>
  </xsd:annotation>
  <xsd:complexType>
   <xsd:choice>
    <xsd:choice minOccurs="0" maxOccurs="unbounded">
     <xsd:annotation>
      <xsd:documentation>
       <h:div class="general">
        <h:p>The main content model of the atom.</h:p>
        <h:ul>
         <h:li>
          <h:b>name</h:b> can be used for atom labels, etc. More than one name can be used if required.
         </h:li>
         <h:li>
          <h:b>scalar</h:b> contains any scalar properties of the atom (examples are chemical shift, B-value, etc.) linked through 
          <h:tt>dictRef</h:tt> (CmlDictRefType).
         </h:li>
         <h:li>
          <h:b>array</h:b> contains any properties of the atom describable by a homogeneous array linked through 
          <h:tt>dictRef</h:tt> (CmlDictRefType).
         </h:li>
         <h:li>
          <h:b>matrix</h:b> contains any properties of the atom describable by a homogeneous matrix linked through 
          <h:tt>dictRef</h:tt> (CmlDictRefType). An example is the polarizability tensor
         </h:li>
         <h:li>
          <h:b>atomParity</h:b> (CmlAtomParityElement) the required way of defining atom-based chirality
         </h:li>
         <h:li>
          <h:b>electron</h:b> a away of associating electron(s) with the atom
         </h:li>
        </h:ul>
       </h:div>
      </xsd:documentation>
     </xsd:annotation>
     <xsd:element ref="name"/>
     <xsd:element ref="label"/>
     <xsd:element ref="atomType"/>
     <xsd:element ref="array"/>
     <xsd:element ref="matrix"/>
     <xsd:element ref="scalar"/>
     <xsd:element ref="atomParity"/>
     <xsd:element ref="electron"/>
     <xsd:element ref="particle"/>
     <xsd:element ref="vector3"/>
    </xsd:choice>
   </xsd:choice>
   <xsd:attributeGroup ref="id"/>
   <xsd:attributeGroup ref="convention"/>
   <xsd:attributeGroup ref="dictRef"/>
   <xsd:attributeGroup ref="ref"/>
   <xsd:attributeGroup ref="count">
    <xsd:annotation>
     <xsd:documentation>
      <h:div class="specific">Most useful in _formula_ but possibly useful in _atomArray_ where coordinates and connectivity is not defined. No formal default, but assumed to be 1.</h:div>
     </xsd:documentation>
    </xsd:annotation>
   </xsd:attributeGroup>
   <xsd:attributeGroup ref="elementType"/>
   <xsd:attributeGroup ref="formalCharge"/>
   <xsd:attributeGroup ref="hydrogenCount"/>
   <xsd:attributeGroup ref="isotope"/>
   <xsd:attributeGroup ref="isotopeNumber"/>
   <xsd:attributeGroup ref="isotopeRef"/>
   <xsd:attributeGroup ref="isotopeListRef"/>
   <xsd:attributeGroup ref="occupancy"/>
   <xsd:attributeGroup ref="spinMultiplicity"/>
   <xsd:attributeGroup ref="x2"/>
   <xsd:attributeGroup ref="y2"/>
   <xsd:attributeGroup ref="x3"/>
   <xsd:attributeGroup ref="y3"/>
   <xsd:attributeGroup ref="z3"/>
   <xsd:attributeGroup ref="xFract"/>
   <xsd:attributeGroup ref="yFract"/>
   <xsd:attributeGroup ref="zFract"/>
   <xsd:attributeGroup ref="title"/>
   <xsd:attributeGroup ref="role">
    <xsd:annotation>
     <xsd:documentation>
      <h:div class="specific">This can be used to describe the purpose of atoms whose _elementType_s are __dummy__ or __locant__. Vocabulary not controlled.</h:div>
     </xsd:documentation>
    </xsd:annotation>
   </xsd:attributeGroup>
   <xsd:attributeGroup ref="spaceGroupMultiplicity">
    <xsd:annotation>
     <xsd:documentation>
      <h:div class="curation">2005-11-27: Added PMR </h:div>
     </xsd:documentation>
    </xsd:annotation>
   </xsd:attributeGroup>
   <xsd:attributeGroup ref="pointGroupMultiplicity">
    <xsd:annotation>
     <xsd:documentation>
      <h:div class="curation">2005-11-27: Added PMR </h:div>
     </xsd:documentation>
    </xsd:annotation>
   </xsd:attributeGroup>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="atomArray" id="el.atomArray" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">A container for a list of atoms.</h:div>
    <h:div class="description">A child of _molecule_ and contains _atom_ information. There are two strategies: 
     <h:ul>
      <h:li>Create individual _atom_ elements under _atomArray_ (in any order). This gives the greatest flexibility but is the most verbose.</h:li>
      <h:li>Create 
       <h:tt>*Array</h:tt> attributes (e.g. of _elementTypeArrayType_ under _atomArray_. This requires all arrays to be of identical lengths with explicit values for all atoms in every array. This is NOT suitable for complexType atom children such as _atomParity_. It also cannot be checked as easily by schema- and schematron validation. The _atomIDArray_ attribute is mandatory. It is allowed (though not yet recommended) to add _*Array_ children such as _floatArray_ 
      </h:li>
     </h:ul> The attributes are directly related to the scalar attributes under _atom_ which should be consulted for more info.
    </h:div>
    <h:div class="example" href="atomArray1.xml">
     <h:p>Example - these are exactly equivalent representations</h:p>
    </h:div>
   </xsd:documentation>
  </xsd:annotation>
  <xsd:complexType>
   <xsd:sequence>
    <xsd:element ref="atom" minOccurs="0" maxOccurs="unbounded"/>
    <xsd:element ref="array" minOccurs="0" maxOccurs="unbounded"/>
   </xsd:sequence>
   <xsd:attributeGroup ref="title"/>
   <xsd:attributeGroup ref="id"/>
   <xsd:attributeGroup ref="convention"/>
   <xsd:attributeGroup ref="dictRef"/>
   <xsd:attributeGroup ref="ref"/>
   <xsd:attributeGroup ref="elementTypeArray"/>
   <xsd:attributeGroup ref="countArray"/>
   <xsd:attributeGroup ref="formalChargeArray"/>
   <xsd:attributeGroup ref="hydrogenCountArray"/>
   <xsd:attributeGroup ref="occupancyArray"/>
   <xsd:attributeGroup ref="x2Array"/>
   <xsd:attributeGroup ref="y2Array"/>
   <xsd:attributeGroup ref="x3Array"/>
   <xsd:attributeGroup ref="y3Array"/>
   <xsd:attributeGroup ref="z3Array"/>
   <xsd:attributeGroup ref="xFractArray"/>
   <xsd:attributeGroup ref="yFractArray"/>
   <xsd:attributeGroup ref="zFractArray"/>
   <xsd:attributeGroup ref="atomIDArray"/>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="atomicBasisFunction" id="el.atomicBasisFunction" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">An atomicBasisFunction.</h:div>
    <h:div class="description">
     <h:p>An atomic atomicBasisFunction which can be linked to atoms, eigenvalues/vectors etc. Normally contained within _basisSet_ </h:p>
     <h:p>Normally these are atom-centered functions, but they can also serve as "ghost" functions which are centered on points. These can be dummy atoms so that the atomRef mechanism can still be used.</h:p>
     <h:p>This information is required to interpret the eignevector components and map them onto the atom list. However this mapping is normally implicit in the program and so it may be necessary to generate 
      <h:tt>basisSet</h:tt> information for some programs before XML technology can be automatically used to link the components of the CCML document.
     </h:p>
    </h:div>
    <h:div class="example" href="atomicBasisFunction1.xml"/>
   </xsd:documentation>
  </xsd:annotation>
  <xsd:complexType>
   <xsd:sequence>
    <xsd:choice minOccurs="0" maxOccurs="unbounded"/>
    <xsd:choice minOccurs="0" maxOccurs="1">
     <xsd:element ref="gradient"/>
    </xsd:choice>
   </xsd:sequence>
   <xsd:attributeGroup ref="atomRef">
    <xsd:annotation>
     <xsd:documentation>
      <h:div class="specific">The atom owning this atomicBasisFunction. This reference is required to tie the reported eigenvector components to the list of atoms.</h:div>
     </xsd:documentation>
    </xsd:annotation>
   </xsd:attributeGroup>
   <xsd:attributeGroup ref="title"/>
   <xsd:attributeGroup ref="id"/>
   <xsd:attributeGroup ref="convention"/>
   <xsd:attributeGroup ref="dictRef"/>
   <xsd:attributeGroup ref="n"/>
   <xsd:attributeGroup ref="l"/>
   <xsd:attributeGroup ref="m">
    <xsd:annotation>
     <xsd:documentation>
      <h:div class="specific">This is provided for completeness but we do not see it being widely used and the symbolic representation (lm) is more valuable.</h:div>
     </xsd:documentation>
    </xsd:annotation>
   </xsd:attributeGroup>
   <xsd:attributeGroup ref="symbol">
    <xsd:annotation>
     <xsd:documentation>
      <h:div class="specific">This is a local annotation of the ABF and unlikely to be enumeratable. Thus a split s-orbital could have 3 ABFs with "s", "s'", "s''" but they would all have lm="s".</h:div>
     </xsd:documentation>
    </xsd:annotation>
   </xsd:attributeGroup>
   <xsd:attributeGroup ref="lm">
    <xsd:annotation>
     <xsd:documentation>
      <h:div class="specific">This is a "standard" representation of the ABF, but not enumerated until we decide whether it can be formalised. Examples are "px", "dxy", etc. Note that d-orbitals and higher may be represented with redundant ABFs, e.g. 6 d-orbitals. The more standard the representation, the more useful this will be for searching.</h:div>
     </xsd:documentation>
    </xsd:annotation>
   </xsd:attributeGroup>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="atomParity" id="el.atomParity" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">The stereochemistry round an atom centre.</h:div>
    <h:div class="description">It follows the convention of the MIF format, and uses 4 distinct atoms to define the chirality. These can be any atoms (though they are normally bonded to the current atom). There is no default order and the order is defined by the atoms in the atomRefs4 attribute. If there are only 3 ligands, the current atom should be included in the 4 atomRefs. 
     <h:p>The value of the parity is a signed number. (It can only be zero if two or more atoms are coincident or the configuration is planar). The sign is the sign of the chiral volume created by the four atoms (a1, a2, a3, a4):</h:p>
     <h:pre> | 1 1 1 1 | | x1 x2 x3 x4 | | y1 y2 y3 y4 | | z1 z2 z3 z4 | </h:pre>
     <h:p>Note that 
      <h:tt>atomParity</h:tt> cannot be used with the *Array syntax for atoms.
     </h:p>
    </h:div>
    <h:div class="example" href="atomParity1.xml"/>
   </xsd:documentation>
  </xsd:annotation>
  <xsd:complexType>
   <xsd:simpleContent>
    <xsd:extension base="xsd:double">
     <xsd:attributeGroup ref="title"/>
     <xsd:attributeGroup ref="id"/>
     <xsd:attributeGroup ref="convention"/>
     <xsd:attributeGroup ref="dictRef"/>
     <xsd:attributeGroup ref="atomRefs4"/>
    </xsd:extension>
   </xsd:simpleContent>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="atomSet" id="el.atomSet" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">A set of references to atoms.</h:div>
    <h:div class="description">An atomSet consists of a number of unique references to atoms throught their ids. atomSets need not be related to molecules (which are generally created by aggregation of explicit atoms). Two or more atomSets may reference the same atom, and atomSets may be empty. 
     <h:p>atomSets have many potential uses such as: 
      <h:ul>
       <h:li>identifying functional groups</h:li>
       <h:li>results of substructure matching</h:li>
       <h:li>identifying atoms with particular roles in a calculation</h:li>
      </h:ul>
     </h:p>
     <h:p>The atomSet may be referenced from elsewhere in the document and you are encouraged to use locally unique id attributes on atomSets. </h:p>
    </h:div>
    <h:div class="example" href="atomSet1.xml"/>
   </xsd:documentation>
  </xsd:annotation>
  <xsd:complexType>
   <xsd:simpleContent>
    <xsd:extension base="atomRefArrayType">
     <xsd:attributeGroup ref="title"/>
     <xsd:attributeGroup ref="id"/>
     <xsd:attributeGroup ref="convention"/>
     <xsd:attributeGroup ref="dictRef"/>
     <xsd:attributeGroup ref="size"/>
    </xsd:extension>
   </xsd:simpleContent>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="atomType" id="el.atomType" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">An atomType.</h:div>
    <h:div class="description">
     <h:p>atomTypes are used in a wide variety of ways in computational chemistry. They are normally labels added to existing atoms (or dummy atoms) in the molecule and have a number of defined properties. These properties are usually in addition to those deducible from the elementType of the atom. AtomTypes usually depend on the chemical or geometrical environment of the atom and are frequently assigned by algorithms with chemical perception. However they are often frequently set or "tweaked" by humans initiating a program run.</h:p>
     <h:p>AtomTypes on an atom have no formal relation to its 
      <h:tt>elementType</h:tt>, which only describe the number of protons in the nucleus. It is not unknown (though potentially misleading) to use an "incompatible" atomType to alter the computational properties of an atom (e.g. pretend this K+ is a Ca++ to increase its effective charge). 
      <h:tt>atomTypes</h:tt> will also be required to describe pseudoAtoms such as "halogen" (generic) or "methyl group" (unified atom). Atoms in computations can therefore have an 
      <h:tt>atomType</h:tt> child with a "ref" attribute.
     </h:p>
     <h:p>An atomType contains numeric or other quantities associated with it (charges, masses, use in force-fields, etc.) and also description of any perception algorithms (chemical and/or geometrical) which could be used to compute or constrain it. This is still experimental.</h:p>
     <h:p>atomTypes are referred to by their mandatory 
      <h:tt>name</h:tt> attribute. An atom refers to one or more atomTypes through atomType/@ref children
     </h:p>
    </h:div>
    <h:div class="example" href="atomType1.xml"/>
    <h:div class="note">examples not yet teste.</h:div>
   </xsd:documentation>
  </xsd:annotation>
  <xsd:complexType>
   <xsd:sequence>
    <xsd:choice minOccurs="0" maxOccurs="unbounded">
     <xsd:element ref="molecule"/>
     <xsd:element ref="atom"/>
     <xsd:element ref="label"/>
    </xsd:choice>
    <xsd:choice minOccurs="0" maxOccurs="unbounded">
     <xsd:element ref="scalar"/>
     <xsd:element ref="array"/>
     <xsd:element ref="matrix"/>
     <xsd:element ref="property"/>
    </xsd:choice>
   </xsd:sequence>
   <xsd:attributeGroup ref="name">
    <xsd:annotation>
     <xsd:documentation>
      <h:div class="specific">The name will usually be namespaced as 'gulp:si', 'tripos:c.3', etc. It must occur except for atomType/@re.</h:div>
     </xsd:documentation>
    </xsd:annotation>
   </xsd:attributeGroup>
   <xsd:attributeGroup ref="ref"/>
   <!-- what do we need this for? -->
   <xsd:attributeGroup ref="atomRef"/>
   <xsd:attributeGroup ref="title"/>
   <xsd:attributeGroup ref="id"/>
   <xsd:attributeGroup ref="convention"/>
   <xsd:attributeGroup ref="dictRef"/>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="atomTypeList" id="el.atomTypeList" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">A container for one or more atomTypes.</h:div>
    <h:div class="description">It can contain several atomTypes.</h:div>
    <h:div class="example" href="atomTypeList1.xml"/>
   </xsd:documentation>
  </xsd:annotation>
  <xsd:complexType>
   <xsd:sequence>
    <xsd:element ref="metadataList" minOccurs="0" maxOccurs="unbounded"/>
    <xsd:element ref="name" minOccurs="0" maxOccurs="unbounded"/>
    <xsd:element ref="atomType" minOccurs="0" maxOccurs="unbounded"/>
   </xsd:sequence>
   <xsd:attributeGroup ref="dictRef"/>
   <xsd:attributeGroup ref="convention"/>
   <xsd:attributeGroup ref="title"/>
   <xsd:attributeGroup ref="id"/>
   <xsd:attributeGroup ref="ref"/>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="band" id="el.band" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">A band or Brillouin zone.</h:div>
    <h:div class="description">Not yet finalised.</h:div>
    <h:div class="example" href="band1.xml"/>
    <h:div class="curation">2006-01-21: PMR. added kpointRef and deprecated kpointList.</h:div>
   </xsd:documentation>
  </xsd:annotation>
  <xsd:complexType>
   <xsd:sequence>
    <xsd:element ref="array" minOccurs="1" maxOccurs="1">
     <xsd:annotation>
      <xsd:documentation>
       <h:div class="summary">Band energies associated with this kpoint.</h:div>
       <h:div class="description">The energy units must be given.</h:div>
      </xsd:documentation>
     </xsd:annotation>
    </xsd:element>
   </xsd:sequence>
   <xsd:attributeGroup ref="kpoint">
    <xsd:annotation>
     <xsd:documentation>
      <h:div class="deprecated">kpoints should be described in kpointList and referenced.</h:div>
     </xsd:documentation>
    </xsd:annotation>
   </xsd:attributeGroup>
   <xsd:attributeGroup ref="kpointRef"/>
   <xsd:attributeGroup ref="weight"/>
   <xsd:attributeGroup ref="label"/>
   <xsd:attributeGroup ref="title"/>
   <xsd:attributeGroup ref="id"/>
   <xsd:attributeGroup ref="convention"/>
   <xsd:attributeGroup ref="dictRef"/>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="bandList" id="el.bandList" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">A container for bands.</h:div>
    <h:div class="description">Experimental.</h:div>
    <h:div class="example" href="band1.xml"/>
   </xsd:documentation>
  </xsd:annotation>
  <xsd:complexType>
   <xsd:sequence>
    <xsd:choice minOccurs="0" maxOccurs="unbounded">
     <xsd:element ref="band"/>
    </xsd:choice>
   </xsd:sequence>
   <xsd:attributeGroup ref="title"/>
   <xsd:attributeGroup ref="id"/>
   <xsd:attributeGroup ref="convention"/>
   <xsd:attributeGroup ref="dictRef"/>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="basisSet" id="el.basisSet" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">A container for one or more atomicBasisFunctions.</h:div>
    <h:div class="description">This can contain several orbitals.</h:div>
    <h:div class="example" href="basisSet1.xml"/>
   </xsd:documentation>
  </xsd:annotation>
  <xsd:complexType>
   <xsd:sequence>
    <xsd:element ref="metadataList" minOccurs="0" maxOccurs="unbounded"/>
    <xsd:element ref="name" minOccurs="0" maxOccurs="unbounded"/>
    <xsd:choice minOccurs="0" maxOccurs="unbounded">
     <xsd:element ref="atomicBasisFunction"/>
    </xsd:choice>
   </xsd:sequence>
   <xsd:attributeGroup ref="dictRef"/>
   <xsd:attributeGroup ref="convention"/>
   <xsd:attributeGroup ref="title"/>
   <xsd:attributeGroup ref="id"/>
   <xsd:attributeGroup ref="ref"/>
   <xsd:attributeGroup ref="role"/>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="bond" id="el.bond" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">A bond between atoms, or between atoms and bonds.</h:div>
    <h:div class="description">_bond_ is a child of _bondArray_ and contains bond information. Bond must refer to at least two atoms (normally using _atomRefs2_) but may also refer to more for multicentre bonds. Bond is often EMPTY but may contain _electron_, _length_ or _bondStereo_ elements.</h:div>
    <h:div class="example" href="bond1.xml"/>
    <!-- <h:div class="example" href="bond2.xml"></h:div> -->
   </xsd:documentation>
   <xsd:documentation>
    <h:div class="validation" href="cmlCore.val.bond.xml"/>
   </xsd:documentation>
   <xsd:appinfo>
    <comment xmlns="">Validate Bonds</comment>
    <template match="bond" id="val-bond" xmlns="">
     <comment>Atom Refs for 2-atom bond</comment>
     <variable name="at1" select="substring-before(normalize-space(@atomRefs2),' ')"/>
     <variable name="at2" select="substring-after(normalize-space(@atomRefs2),' ')"/>
     <comment>Are atoms distinct?</comment>
     <if test="$at1 = $at2">
      <call-template name="error">
       <with-param name="error">BOND (
        <value-of select="@id"/>): ATOMS not distinct: 
        <value-of select="$at1"/>
       </with-param>
      </call-template>
     </if>
     <comment>Do both atoms exist in current molecule context?</comment>
     <if test="not(key('atoms', $at1))">
      <call-template name="error">
       <with-param name="error">BOND (
        <value-of select="@id"/>): ATOMREF not found: 
        <value-of select="$at1"/>
       </with-param>
      </call-template>
     </if>
     <if test="not(key('atoms', $at2))">
      <call-template name="error">
       <with-param name="error">BOND (
        <value-of select="@id"/>): ATOMREF not found: 
        <value-of select="$at2"/>
       </with-param>
      </call-template>
     </if>
    </template>
   </xsd:appinfo>
  </xsd:annotation>
  <xsd:complexType id="bond.content.id">
   <xsd:choice>
    <xsd:choice minOccurs="0" maxOccurs="unbounded">
     <xsd:element ref="bondType"/>
     <xsd:element ref="electron">
      <xsd:annotation>
       <xsd:documentation>
        <h:div class="summary">One or more electrons associated with the bond.</h:div>
        <h:div class="description">The _bondRef_ on the _electron_ should point to the id on the bond. We may relax this later and allow reference by context.</h:div>
       </xsd:documentation>
      </xsd:annotation>
     </xsd:element>
     <xsd:element ref="bondStereo">
      <xsd:annotation>
       <xsd:documentation>
        <h:div class="summary">The stereo convention for the bond.</h:div>
        <h:div class="general">only one convention allowed.</h:div>
       </xsd:documentation>
      </xsd:annotation>
     </xsd:element>
    </xsd:choice>
   </xsd:choice>
   <xsd:attributeGroup ref="title"/>
   <xsd:attributeGroup ref="id"/>
   <xsd:attributeGroup ref="convention"/>
   <xsd:attributeGroup ref="dictRef"/>
   <xsd:attributeGroup ref="ref"/>
   <xsd:attributeGroup ref="atomRefs2"/>
   <xsd:attributeGroup ref="atomRefs">
    <xsd:annotation>
     <xsd:documentation>
      <h:div class="specific">This is designed for multicentre bonds (as in delocalised systems or electron-deficient centres. The semantics are experimental at this stage. As an example, a B-H-B bond might be described as &lt;bond atomRefs="b1 h2 b2"/.</h:div>
     </xsd:documentation>
    </xsd:annotation>
   </xsd:attributeGroup>
   <xsd:attributeGroup ref="bondRefs">
    <xsd:annotation>
     <xsd:documentation>
      <h:div class="specific">This is designed for pi-bonds and other systems where formal valence bonds are not drawn to atoms. The semantics are experimental at this stage. As an example, a Pt-|| bond (as the Pt-ethene bond in Zeise's salt) might be described as &lt;bond atomRefs="pt1" bondRefs="b32"/.</h:div>
     </xsd:documentation>
    </xsd:annotation>
   </xsd:attributeGroup>
   <xsd:attributeGroup ref="order"/>
   <xsd:attributeGroup ref="cyclic">
    <xsd:annotation>
     <xsd:documentation>
      <h:div class="specific">A user- or machine- assertion about the cyclic nature of a bond. Need NOT agree with the apparent cyclicity from the connection table.</h:div>
     </xsd:documentation>
    </xsd:annotation>
   </xsd:attributeGroup>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="bondArray" id="el.bondArray" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">A container for a number of bonds.</h:div>
    <h:div class="description">_bondArray_ is a child of _molecule_ and contains _bond_ information. There are two strategies: 
     <h:ul>
      <h:li>Create individual 
       <h:tt>bond</h:tt> elements under 
       <h:tt>bondArray</h:tt> (in any order). This gives the greatest flexibility but is the most verbose.
      </h:li>
      <h:li>Create 
       <h:tt>*Array</h:tt> attributes (e.g. of 
       <h:tt>orderArrayType</h:tt> under 
       <h:tt>bondArray</h:tt>. This requires all arrays to be of identical lengths with explicit values for all bonds in every array. This is NOT suitable for complexType bond children such as _bondStereo_ nor can IDs be added to bonds.. It also cannot be checked as easily by schema- and schematron validation. The _atomRef1Array_ and _atomRef2Array_ attributes are then mandatory. It is allowed (though not yet recommended) to add _*Array_ children such as _floatArray_ 
      </h:li>
     </h:ul>
     <h:p>The attributes are directly related to the scalar attributes under _atom_ which should be consulted for more info.</h:p>
    </h:div>
    <h:div class="example" href="bondArray1.xml">
     <h:p>Example - these are exactly equivalent representations</h:p>
    </h:div>
   </xsd:documentation>
  </xsd:annotation>
  <xsd:complexType>
   <xsd:choice>
    <xsd:element ref="bond" maxOccurs="unbounded"/>
    <xsd:element ref="array" minOccurs="0" maxOccurs="unbounded"/>
   </xsd:choice>
   <xsd:attributeGroup ref="title"/>
   <xsd:attributeGroup ref="id"/>
   <xsd:attributeGroup ref="convention"/>
   <xsd:attributeGroup ref="dictRef"/>
   <xsd:attributeGroup ref="bondIDArray"/>
   <xsd:attributeGroup ref="atomRef1Array"/>
   <xsd:attributeGroup ref="atomRef2Array"/>
   <xsd:attributeGroup ref="orderArray"/>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="bondSet" id="el.bondSet" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">A set of references to bonds.</h:div>
    <h:div class="description">An bondSet consists of a number of unique references to bonds throught their ids. bondSets need not be related to molecules (which are generally created by aggregation of explicit bonds). Two or more bondSets may reference the same bond, and bondSets may be empty. 
     <h:p>bondSets have many potential uses such as: 
      <h:ul>
       <h:li>identifying functional groups</h:li>
       <h:li>results of substructure matching</h:li>
       <h:li>identifying bonds with particular roles in a calculation</h:li>
      </h:ul>
     </h:p>
     <h:p>The bondSet may be referenced from elsewhere in the document and you are encouraged to use locally unique id attributes on bondSets. </h:p>
    </h:div>
    <h:div class="example" href="bondSet1.xml"/>
   </xsd:documentation>
  </xsd:annotation>
  <xsd:complexType>
   <xsd:simpleContent>
    <xsd:extension base="bondRefArrayType">
     <xsd:attributeGroup ref="title"/>
     <xsd:attributeGroup ref="id"/>
     <xsd:attributeGroup ref="convention"/>
     <xsd:attributeGroup ref="dictRef"/>
     <xsd:attributeGroup ref="size"/>
    </xsd:extension>
   </xsd:simpleContent>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="bondStereo" id="el.bondStereo" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">A container supporting cis trans wedge hatch and other stereochemistry.</h:div>
    <h:div class="description">
     <h:p>An explict list of atomRefs must be given, or it must be a child of 
      <h:tt>bond</h:tt>. There are no implicit conventions such as E/Z. This will be extended to other types of stereochemistry.
     </h:p>
     <h:p>At present the following are supported:</h:p>
     <h:ul>
      <h:li>No atomRefs attribute. 
       <h:b>Deprecated, but probably unavoidable</h:b>. This must be a child of 
       <h:tt>bond</h:tt> where it picks up the two atomRefs in the 
       <h:tt>atomRefs2</h:tt> attribute. Possible values are C/T (which only makes sense if there is exactly one ligand at each end of the bond) and W/H. The latter should be raplaced by 
       <h:tt>atomParity</h:tt> wherever possible. Note that W/H makes no sense without 2D atom coordinates.
      </h:li>
      <h:li>
       <h:b>atomRefs4 attribute</h:b>. The 4 atoms represent a cis or trans configuration. This may or may not be a child of 
       <h:tt>bond</h:tt>; if so the second and third atomRefs should be identical with the two atomRefs in the bond. This structure can be used to guide processors in processing stereochemistry and is recommended, since there is general agreement on the semantics. The semantics of 
       <h:tt>bondStereo</h:tt> not related to bonds is less clear (e.g. cumulenes, substituted ring nuclei) etc.It is currently an error to have more than one 
       <h:tt>bondStereo</h:tt> referring to the same ordered 4-atom list
      </h:li>
      <h:li>
       <h:b>atomRefs attribute</h:b>. There are other stereochemical conventions such as cis/trans for metal complexes which require a variable number of reference atoms. This allows users to create their own - at present we do not see CML creating exhaustive tables. For example cis/trans square-planar complexes might require 4 (or 5) atoms for their definition, octahedral 6 or 7, etc. In principle this is very powerful and could supplement or replace the use of 
       <h:i>cis-</h:i>, 
       <h:i>mer-</h:i>, etc.
      </h:li>
     </h:ul>
     <h:p>the 
      <h:tt>atomRefs</h:tt> and 
      <h:tt>atomRefs4</h:tt> attributes cannot be used simultaneously.
     </h:p>
    </h:div>
    <h:div class="example" href="bondStereo1.xml"/>
   </xsd:documentation>
  </xsd:annotation>
  <xsd:complexType>
   <xsd:simpleContent>
    <xsd:extension base="stereoType">
     <xsd:attributeGroup ref="atomRefs4"/>
     <xsd:attributeGroup ref="atomRefArray"/>
     <xsd:attributeGroup ref="title"/>
     <xsd:attributeGroup ref="id"/>
     <xsd:attributeGroup ref="convention"/>
     <xsd:attributeGroup ref="dictRef"/>
     <xsd:attributeGroup ref="conventionValue"/>
    </xsd:extension>
   </xsd:simpleContent>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="bondType" id="el.bondType" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">The type of a bond.</h:div>
    <h:div class="description">Bond types are used to describe the behaviour of bonds in forcefields, functional groups, reactions and many other domains. They are not as well formalised as atomTypes and we provide less semantic support. BondTypes are referred to by their mandatory _name_ attribute.</h:div>
    <h:div class="example" href="bondType1.xml"/>
   </xsd:documentation>
  </xsd:annotation>
  <xsd:complexType>
   <xsd:sequence>
    <xsd:choice minOccurs="0" maxOccurs="unbounded">
     <xsd:element ref="molecule"/>
     <xsd:element ref="bond"/>
     <xsd:element ref="label"/>
    </xsd:choice>
    <xsd:choice minOccurs="0" maxOccurs="unbounded">
     <xsd:element ref="scalar"/>
     <xsd:element ref="array"/>
     <xsd:element ref="matrix"/>
     <xsd:element ref="property"/>
    </xsd:choice>
   </xsd:sequence>
   <xsd:attributeGroup ref="name">
    <xsd:annotation>
     <xsd:documentation>
      <h:div class="specific">The bondType name. The name will usually be namespaced as 'gulp:si', 'tripos:c.3', etc. It must occur except when the ref attribute is given.</h:div>
     </xsd:documentation>
    </xsd:annotation>
   </xsd:attributeGroup>
   <xsd:attributeGroup ref="ref"/>
   <xsd:attributeGroup ref="title"/>
   <xsd:attributeGroup ref="id"/>
   <xsd:attributeGroup ref="convention"/>
   <xsd:attributeGroup ref="dictRef"/>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="bondTypeList" id="el.bondTypeList" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">A container for one or more bondTypes.</h:div>
    <h:div class="description">_bondTypeList_ can contain several bondTypes.</h:div>
    <h:div class="example" href="bondTypeList1.xml"/>
   </xsd:documentation>
  </xsd:annotation>
  <xsd:complexType>
   <xsd:sequence>
    <xsd:element ref="metadataList" minOccurs="0" maxOccurs="unbounded"/>
    <xsd:element ref="name" minOccurs="0" maxOccurs="unbounded"/>
    <xsd:choice minOccurs="0" maxOccurs="unbounded">
     <xsd:element ref="bondType"/>
    </xsd:choice>
   </xsd:sequence>
   <xsd:attributeGroup ref="dictRef"/>
   <xsd:attributeGroup ref="convention"/>
   <xsd:attributeGroup ref="title"/>
   <xsd:attributeGroup ref="id"/>
   <xsd:attributeGroup ref="ref"/>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="cellParameter" id="el.cellParameter" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">A set of 3 cell parameters.</h:div>
    <h:div class="description">Either 3 lengths or 3 angles.</h:div>
   </xsd:documentation>
  </xsd:annotation>
  <xsd:complexType>
   <xsd:simpleContent>
    <xsd:extension base="vector3Type">
     <xsd:attributeGroup ref="convention"/>
     <xsd:attributeGroup ref="dictRef"/>
     <xsd:attributeGroup ref="id"/>
     <xsd:attributeGroup ref="title"/>
     <xsd:attributeGroup ref="units"/>
     <xsd:attributeGroup ref="cellParameterType"/>
     <xsd:attributeGroup ref="cellParameterError"/>
    </xsd:extension>
   </xsd:simpleContent>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="cml" id="el.cml" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">A general container for CML elements.</h:div>
    <h:div class="description">Often the root of the CML (sub)document. Has no explicit function but can serve to hold the dictionary and namespace and version information, and is a useful tag to alert CML processors and search/XMLQuery tools that there is chemistry in the document. Can contain any content, but usually a list of molecules and other CML components. The fileId attribute can be used to preserve the origin of the information, though metadat should also be used. Can be nested.</h:div>
    <h:div class="example" href="cml1.xml"/>
   </xsd:documentation>
  </xsd:annotation>
  <xsd:complexType>
   <xsd:sequence minOccurs="0" maxOccurs="unbounded">
    <xsd:annotation>
     <xsd:documentation>
      <h:div class="description">No specific restrictions..</h:div>
     </xsd:documentation>
    </xsd:annotation>
    <xsd:any processContents="lax"/>
   </xsd:sequence>
   <xsd:attributeGroup ref="title"/>
   <xsd:attributeGroup ref="id"/>
   <xsd:attributeGroup ref="convention"/>
   <xsd:attributeGroup ref="dictRef"/>
   <xsd:attributeGroup ref="fileId"/>
   <xsd:attributeGroup ref="version"/>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="complexObject" id="el.complexObject" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">An element to hold any combination of heterogeneous element children</h:div>
    <h:div class="description">complexObject can be used as it stands but will often be extended by schema definitions in dictionary entries.</h:div>
    <h:div class="example" href="complexObject1.xml"/>
   </xsd:documentation>
  </xsd:annotation>
  <xsd:complexType>
   <xsd:sequence>
    <xsd:any processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
   </xsd:sequence>
   <xsd:attributeGroup ref="title"/>
   <xsd:attributeGroup ref="id"/>
   <xsd:attributeGroup ref="convention"/>
   <xsd:attributeGroup ref="dictRef"/>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="conditionList" id="el.conditionList" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">A container for one or more experimental conditions.</h:div>
    <h:div class="description">This can contain several conditions. These include (but are not limited to) intensive physical properties (temperature, pressure, etc.), apparatus (test-tube, rotary evaporator, etc.). Actions can be represented elsewhere by actionList and solvents or other substances by substanceList.</h:div>
    <h:div class="example" href="conditionList1.xml"/>
   </xsd:documentation>
  </xsd:annotation>
  <xsd:complexType>
   <xsd:sequence>
    <xsd:element ref="metadataList" minOccurs="0" maxOccurs="unbounded"/>
    <xsd:element ref="name" minOccurs="0" maxOccurs="unbounded"/>
    <xsd:choice minOccurs="0" maxOccurs="unbounded">
     <xsd:element ref="scalar"/>
     <xsd:element ref="list"/>
    </xsd:choice>
    <!-- <xsd:any processContents="lax" minOccurs="0" maxOccurs="unbounded"/>-->
   </xsd:sequence>
   <xsd:attributeGroup ref="dictRef"/>
   <xsd:attributeGroup ref="convention"/>
   <xsd:attributeGroup ref="title"/>
   <xsd:attributeGroup ref="id"/>
   <xsd:attributeGroup ref="ref"/>
   <xsd:attributeGroup ref="role"/>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="crystal" id="el.crystal" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">A crystallographic cell.</h:div>
    <h:div class="description">Required if fractional coordinates are provided for a molecule. Originally there were precisely SIX child 
     <h:tt>scalar</h:tt>s to represent the cell lengths and angles in that order. There are no default values; the spacegroup is also included. This is now deprecated and replaced by cellParameter 
    </h:div>
    <h:div class="curation">2006-03-06 PMR: added cellParameter child</h:div>
    <h:div class="example" href="crystal1.xml"/>
   </xsd:documentation>
  </xsd:annotation>
  <xsd:complexType>
   <xsd:sequence>
    <xsd:annotation>
     <xsd:documentation>
      <h:div class="description">OLD STYLE: All 6 cell parameters must be given, even where angles are fixed by symmetry. The order is fixed as a,b,c,alpha,beta,gamma and software can neglect any title or dictRef attributes. Error estimates can be given if required. Any units can be used, but the defaults are Angstrom (10^-10 m) and degrees.</h:div>
      <h:div class="description">NEW STYLE: Two cellParameter children are given</h:div>
     </xsd:documentation>
    </xsd:annotation>
    <xsd:choice minOccurs="0" maxOccurs="1">
     <xsd:element ref="scalar" minOccurs="6" maxOccurs="6"/>
     <xsd:element ref="cellParameter" minOccurs="1" maxOccurs="2"/>
    </xsd:choice>
    <xsd:element ref="symmetry" minOccurs="0"/>
   </xsd:sequence>
   <xsd:attributeGroup ref="z"/>
   <xsd:attributeGroup ref="title"/>
   <xsd:attributeGroup ref="id"/>
   <xsd:attributeGroup ref="convention"/>
   <xsd:attributeGroup ref="dictRef"/>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="definition" id="el.definition" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">The definition for an entry.</h:div>
    <h:div class="description">The definition should be a short nounal phrase defining the subject of the entry. Definitions should not include commentary, implementations, equations or formulae (unless the subject is one of these) or examples. 
     <h:p>The definition can be in any markup language, but normally XHTML will be used, perhaps with links to other XML namespaces such as CML for chemistry.</h:p>
    </h:div>
    <h:div class="example" href="definition1.xml">
     <h:em>From the IUPAC Dictionary of Medicinal Chemistry</h:em>
     <h:br/>
    </h:div>
   </xsd:documentation>
  </xsd:annotation>
  <xsd:complexType mixed="true">
   <xsd:sequence minOccurs="0" maxOccurs="unbounded">
    <xsd:any processContents="lax"/>
   </xsd:sequence>
   <xsd:attributeGroup ref="id"/>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="description" id="el.description" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">Descriptive information.</h:div>
    <h:div class="description">This can occur in objects which require textual comment such as entry. 
     <h:p>Entries should have at least one separate 
      <h:a href="el.definition">definition</h:a>s. 
      <h:tt>description</h:tt> is then used for most of the other information, including examples. The 
      <h:tt>class</h:tt> attribute has an uncontrolled vocabulary and can be used to clarify the purposes of the 
      <h:tt>description</h:tt> elements.
     </h:p>
    </h:div>
    <h:div class="example" href="description1.xml"/>
   </xsd:documentation>
  </xsd:annotation>
  <xsd:complexType mixed="true">
   <xsd:sequence minOccurs="0" maxOccurs="unbounded">
    <xsd:any processContents="lax"/>
   </xsd:sequence>
   <xsd:attributeGroup ref="convention"/>
   <xsd:attributeGroup ref="id"/>
   <xsd:attributeGroup ref="title"/>
   <xsd:attributeGroup ref="dictRef"/>
   <xsd:attributeGroup ref="objectClass"/>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="dictionary" id="el.dictionary" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">A dictionary.</h:div>
    <h:div class="description">A dictionary is a container for _entry_ elements. Dictionaries can also contain unit-related information. The dictRef attribute on a dictionary element sets a namespace-like prefix allowing the dictionary to be referenced from within the document. In general dictionaries are referenced from an element using the __dictRef__ attribute.</h:div>
    <h:div class="example" href="dictionary1.xml"/>
    <!-- <h:div class="example" href="dictionary2.xml"> <h:p> <h:tt>dictionary</h:tt> can be used in an instance document to reference the dictionary used. Example:</h:p></h:div> -->
    <h:div class="curation">2005-12-15. PMR. added namespace and dictionaryPrefix.</h:div>
   </xsd:documentation>
  </xsd:annotation>
  <xsd:complexType>
   <xsd:sequence>
    <xsd:element ref="unitList" minOccurs="0" maxOccurs="unbounded"/>
    <xsd:element ref="annotation" minOccurs="0" maxOccurs="unbounded"/>
    <xsd:element ref="description" minOccurs="0" maxOccurs="unbounded"/>
    <xsd:element ref="entry" minOccurs="0" maxOccurs="unbounded"/>
   </xsd:sequence>
   <xsd:attributeGroup ref="title"/>
   <xsd:attributeGroup ref="id"/>
   <xsd:attributeGroup ref="convention"/>
   <xsd:attributeGroup ref="dictRef"/>
   <xsd:attributeGroup ref="href"/>
   <xsd:attributeGroup ref="namespace"/>
   <xsd:attributeGroup ref="dictionaryPrefix"/>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="dimension" id="el.dimension" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">A dimension supporting scientific unit.</h:div>
    <h:div class="description">This will be primarily used within the definition of units. Two dimensions are of the same type if their 'name' attributes are (case-sensitive) identical. Dimensions of the same typecan be algebraically combined using the 'power' attributes. Normally dimensions will be aggregated and cancelled algebraically, but the 'preserve' attribute can be used to prevent this. Thus a velocity gradient over length can be defined as: 
     <h:pre>
      <unitType id="a1" preserve="true" xmlns="">
       <dimension name="length" power="1"/>
       <dimension name="time" power="-1"/>
       <dimension name="length" power="-1"/>
      </unitType>
     </h:pre> whereas cancelling the dimensions would give: 
     <h:pre>
      <unitType id="a1" preserve="true" xmlns="">
       <dimension name="time" power="-1"/>
      </unitType>
     </h:pre>
    </h:div>
    <h:div class="example" href="dimension1.xml"/>
    <h:div class="example" href="dimension2.xml"/>
   </xsd:documentation>
  </xsd:annotation>
  <xsd:complexType>
   <xsd:sequence/>
   <xsd:attributeGroup ref="dimensionBasis"/>
   <xsd:attributeGroup ref="id"/>
   <xsd:attributeGroup ref="name"/>
   <xsd:attributeGroup ref="power"/>
   <xsd:attributeGroup ref="preserve"/>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="documentation" id="el.documentation" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">Documentation in the annotation of an entry.</h:div>
    <h:div class="description">
     <h:p>A container similar to 
      <h:tt>documentation</h:tt> in XML Schema. This is NOT part of the textual content of an entry but is designed to support the transformation of dictionary entrys into schemas for validation. This is experimental and should only be used for dictionaries, units, etc. One approach is to convert these into XML Schemas when the 
      <h:tt>documentation</h:tt> and 
      <h:tt>appinfo</h:tt> children will emerge in their correct position in the derived schema.
     </h:p>
     <h:p>Do NOT confuse documentation with the description or the definition which are part of the content of the dictionary</h:p>
     <h:p>If will probably only be used when there is significant appinfo in the entry or where the entry defines an XSD-like datatype of an element in the document.</h:p>
    </h:div>
    <h:div class="example" href="documentation1.xml"/>
   </xsd:documentation>
  </xsd:annotation>
  <xsd:complexType mixed="true">
   <xsd:sequence minOccurs="0" maxOccurs="unbounded">
    <xsd:any processContents="lax"/>
   </xsd:sequence>
   <xsd:attributeGroup ref="id"/>
   <xsd:attributeGroup ref="title"/>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="eigen" id="el.eigen" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">An element to hold eigenstuff.</h:div>
    <h:div class="description">Holds an array of eigenvalues and a matrix of eigenvectors.</h:div>
    <h:div class="example" href="eigen1.xml"/>
   </xsd:documentation>
  </xsd:annotation>
  <xsd:complexType>
   <xsd:sequence>
    <xsd:element ref="array" minOccurs="0"/>
    <xsd:element ref="matrix" minOccurs="0"/>
   </xsd:sequence>
   <xsd:attributeGroup ref="units"/>
   <xsd:attributeGroup ref="title"/>
   <xsd:attributeGroup ref="id"/>
   <xsd:attributeGroup ref="convention"/>
   <xsd:attributeGroup ref="dictRef"/>
   <xsd:attributeGroup ref="type">
    <xsd:annotation>
     <xsd:documentation>
      <h:div class="summary">No current semantics.</h:div>
      <h:div class="description">Suggest it is developed for the chemical/physical role, e.g. "molecular obitals", "inertial matrix", "vibrational modes", "phonons", etc.</h:div>
     </xsd:documentation>
    </xsd:annotation>
   </xsd:attributeGroup>
   <xsd:attributeGroup ref="eigenOrientation"/>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="electron" id="el.electron" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">An electron.</h:div>
    <h:div class="description">Since there is very little use of electrons in current chemical information this is a fluid concept. I expect it to be used for electron counting, input and output of theochem operations, descriptions of orbitals, spin states, oxidation states, etc. Electrons can be associated with atoms, bonds and combinations of these. At present there is no hardcoded semantics. However, _atomRef_ and similar attributes can be used to associate electrons with atoms or bond.</h:div>
    <h:div class="example" href="electron1.xml"/>
   </xsd:documentation>
  </xsd:annotation>
  <xsd:complexType>
   <xsd:sequence/>
   <xsd:attributeGroup ref="title"/>
   <xsd:attributeGroup ref="id"/>
   <xsd:attributeGroup ref="convention"/>
   <xsd:attributeGroup ref="dictRef"/>
   <xsd:attributeGroup ref="atomRef"/>
   <xsd:attributeGroup ref="atomRefs"/>
   <xsd:attributeGroup ref="bondRef"/>
   <xsd:attributeGroup ref="bondRefs"/>
   <xsd:attributeGroup ref="count"/>
   <xsd:attributeGroup ref="ref"/>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="entry" id="el.entry" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">A dictionary entry.</h:div>
    <h:div class="description">The original design for validation with attribute-based constraints is ponderous and fragile. In future constraints will be added through 
     <h:tt>appinfo</h:tt> in 
     <h:tt>annotation</h:tt>. We shall develop this further in the near future.
    </h:div>
    <h:div class="curation">2003-03-30: added metadataList to content mode.</h:div>
    <h:div class="curation">2007-01-20: added unitType.</h:div>
    <h:div class="curation">2007-01-20: deprecated alternative, relatedEntry. These require approaches outside CMLSchema (e.g. RDF)</h:div>
    <h:div class="example" href="entry1.xml"/>
    <!-- <h:div class="example" href="entry2.xml"></h:div> -->
   </xsd:documentation>
  </xsd:annotation>
  <xsd:complexType>
   <xsd:sequence>
    <xsd:choice minOccurs="0" maxOccurs="unbounded">
     <xsd:element ref="metadataList"/>
     <xsd:element ref="annotation"/>
     <xsd:element ref="definition"/>
     <xsd:element ref="description"/>
     <xsd:element ref="enumeration"/>
     <xsd:element ref="unitType"/>
     <!-- deprecated -->
     <xsd:element ref="alternative"/>
     <xsd:element ref="relatedEntry"/>
    </xsd:choice>
   </xsd:sequence>
   <xsd:attributeGroup ref="title"/>
   <xsd:attributeGroup ref="id"/>
   <xsd:attributeGroup ref="convention"/>
   <xsd:attributeGroup ref="dataType"/>
   <xsd:attributeGroup ref="rows"/>
   <xsd:attributeGroup ref="columns"/>
   <xsd:attributeGroup ref="unitType"/>
   <xsd:attributeGroup ref="minExclusive"/>
   <xsd:attributeGroup ref="minInclusive"/>
   <xsd:attributeGroup ref="maxExclusive"/>
   <xsd:attributeGroup ref="maxInclusive"/>
   <xsd:attributeGroup ref="totalDigits"/>
   <xsd:attributeGroup ref="fractionDigits"/>
   <xsd:attributeGroup ref="length"/>
   <xsd:attributeGroup ref="minLength"/>
   <xsd:attributeGroup ref="maxLength"/>
   <xsd:attributeGroup ref="units"/>
   <xsd:attributeGroup ref="whiteSpace"/>
   <xsd:attributeGroup ref="pattern"/>
   <xsd:attributeGroup ref="term"/>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="enumeration" id="el.enumeration" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">An enumeration of value.</h:div>
    <h:div class="description">An enumeration of string values. Used where a dictionary entry constrains the possible values in a document instance. The dataTypes (if any) must all be identical and are defined by the dataType of the containing element.</h:div>
    <h:div class="example" href="enumeration1.xml"/>
   </xsd:documentation>
  </xsd:annotation>
  <xsd:complexType>
   <xsd:sequence>
    <xsd:element ref="annotation" minOccurs="0"/>
   </xsd:sequence>
   <xsd:attributeGroup ref="value"/>
   <xsd:attributeGroup ref="id"/>
   <xsd:attributeGroup ref="dictRef"/>
   <xsd:attributeGroup ref="default"/>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="expression" id="el.expression" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">An expression that can be evaluated.</h:div>
    <h:div class="description">Experimental. This is essentially a mathematical function, expressed currently in reverse Polish notation but we expect to move to MathML.</h:div>
    <h:div class="example" href="potential1.xml"/>
   </xsd:documentation>
  </xsd:annotation>
  <xsd:complexType>
   <xsd:sequence>
    <xsd:choice minOccurs="0" maxOccurs="unbounded">
     <xsd:element ref="parameter"/>
     <xsd:element ref="operator"/>
    </xsd:choice>
   </xsd:sequence>
   <xsd:attributeGroup ref="title"/>
   <xsd:attributeGroup ref="id"/>
   <xsd:attributeGroup ref="convention"/>
   <xsd:attributeGroup ref="dictRef"/>
   <xsd:attributeGroup ref="dataType"/>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="float" id="el.float" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">CML-1 dataType DEPRECATED.</h:div>
    <h:div class="description"/>
    <h:div class="example" href="../../examples/cmlone.xml"/>
   </xsd:documentation>
  </xsd:annotation>
  <xsd:complexType>
   <xsd:simpleContent>
    <xsd:extension base="xsd:double">
     <xsd:attributeGroup ref="builtin"/>
     <xsd:attributeGroup ref="convention"/>
     <xsd:attributeGroup ref="dictRef"/>
     <xsd:attributeGroup ref="id"/>
     <xsd:attributeGroup ref="title"/>
     <xsd:attributeGroup ref="min"/>
     <xsd:attributeGroup ref="max"/>
     <xsd:attributeGroup ref="units"/>
     <xsd:attributeGroup ref="unitsRef"/>
    </xsd:extension>
   </xsd:simpleContent>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="floatArray" id="el.floatArray" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">CML-1 dataType DEPRECATED.</h:div>
    <h:div class="description"/>
    <h:div class="example" href="../../examples/cmlone.xml"/>
   </xsd:documentation>
  </xsd:annotation>
  <xsd:complexType>
   <xsd:simpleContent>
    <xsd:extension base="xsd:string">
     <xsd:attributeGroup ref="builtin"/>
     <xsd:attributeGroup ref="convention"/>
     <xsd:attributeGroup ref="dictRef"/>
     <xsd:attributeGroup ref="id"/>
     <xsd:attributeGroup ref="title"/>
     <xsd:attributeGroup ref="min"/>
     <xsd:attributeGroup ref="max"/>
     <xsd:attributeGroup ref="size"/>
     <xsd:attributeGroup ref="units"/>
     <xsd:attributeGroup ref="unitsRef"/>
    </xsd:extension>
   </xsd:simpleContent>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="formula" id="el.formula" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">A molecular formula.</h:div>
    <h:div class="description">
     <h:p>It is defined by 
      <h:tt>atomArray</h:tt>s each with a list of elementTypes and their counts (or default=1). All other information in the 
      <h:tt>atomArray</h:tt> is ignored. 
      <h:tt>formula</h:tt> are nestable so that aggregates (e.g. hydrates, salts, etc.) can be described. CML does not require that formula information is consistent with (say) crystallographic information; this allows for experimental variance.
     </h:p>
     <h:p>An alternative briefer representation is also available through the 
      <h:tt>concise</h:tt>. This must include whitespace round all elements and their counts, which must be explicit. 
     </h:p>
     <h:p>2005-10-16. The semantics are now the following. A formula must have one or both: 
      <h:ul>
       <h:li>A concise attribute </h:li>A single atomArray child, using array format. 
      </h:ul> it must also have a formalCharge attribute if atomArray is used and the charge is non-zero. 
     </h:p>
     <h:p> The concise, formalCharge and atomArrary information must always be consistent and software should throw an error if not. </h:p>
     <h:p> Until now there was no way of holding inline formula other than concise (although JUMBO5.0 is capable of reading them). We now extend formula.xsd to incorporate this through the attribute "inline" which requires the use of the "convention" attribute. The contents of inline are purely textual. It can be used with or without atomArray or concise but there is no guarantee that it can be interpreted as a meaningful chemical formula or that there is consistency. In some cases a document supplies several formula representations (e.g. the IUCr's CIF). In this case a molecule (or crystal) element might contain several formula children. The semantics of which to use are application dependent. </h:p>
    </h:div>
    <h:div class="example" href="formula1.xml"/>
   </xsd:documentation>
  </xsd:annotation>
  <xsd:complexType>
   <xsd:choice>
    <xsd:choice minOccurs="0" maxOccurs="unbounded">
     <xsd:element ref="formula"/>
     <xsd:element ref="atomArray"/>
    </xsd:choice>
   </xsd:choice>
   <xsd:attributeGroup ref="title"/>
   <xsd:attributeGroup ref="id"/>
   <xsd:attributeGroup ref="convention"/>
   <xsd:attributeGroup ref="dictRef"/>
   <xsd:attributeGroup ref="count">
    <xsd:annotation>
     <xsd:documentation>
      <h:div class="specific">Allows for fractional components.</h:div>
     </xsd:documentation>
    </xsd:annotation>
   </xsd:attributeGroup>
   <xsd:attributeGroup ref="formalCharge">
    <xsd:annotation>
     <xsd:documentation>
      <h:div class="specific">The charge on the formula. Mandatory if non-zero (i.e. cannot rely on concise)</h:div>
     </xsd:documentation>
    </xsd:annotation>
   </xsd:attributeGroup>
   <xsd:attributeGroup ref="concise"/>
   <xsd:attributeGroup ref="inline">
    <xsd:annotation>
     <xsd:documentation>
      <h:div class="specific">An inline representation of the formula. There are no controlled semantics and it need not be compatible with concise or atomArray.</h:div>
     </xsd:documentation>
    </xsd:annotation>
   </xsd:attributeGroup>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="fragment" id="el.fragment" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">A container for a fragment</h:div>
    <h:div class="description">
     <h:p>
      <h:tt>fragment</h:tt> is a container for a molecule, potentially to be joined to other fragments. In addition there may be fragmentLists which represent branches from the molecule. There may also be a join child which is normally only found if there is a @countExpression.
     </h:p>
    </h:div>
    <h:div class="example" href="fragment1.xml"/>
    <h:div class="curation">2006-11-23: created</h:div>
   </xsd:documentation>
  </xsd:annotation>
  <xsd:complexType>
   <xsd:annotation>
    <xsd:documentation>
     <h:div class="summary">fragment normally contains molecules</h:div>
    </xsd:documentation>
   </xsd:annotation>
   <xsd:sequence>
    <xsd:choice minOccurs="0" maxOccurs="unbounded">
     <xsd:element ref="metadataList"/>
     <xsd:element ref="label"/>
     <xsd:element ref="molecule"/>
     <xsd:element ref="fragmentList">
      <xsd:annotation>
       <xsd:documentation>
        <h:div class="summary">branches from the moelcule.</h:div>
       </xsd:documentation>
      </xsd:annotation>
     </xsd:element>
     <xsd:element ref="join">
      <xsd:annotation>
       <xsd:documentation>
        <h:div class="summary">the inter-fragment join.</h:div>
        <h:div class="description"> Normally it only makes sense with @countExpression.</h:div>
       </xsd:documentation>
      </xsd:annotation>
     </xsd:element>
    </xsd:choice>
   </xsd:sequence>
   <xsd:attributeGroup ref="dictRef"/>
   <xsd:attributeGroup ref="convention"/>
   <xsd:attributeGroup ref="title"/>
   <xsd:attributeGroup ref="id"/>
   <xsd:attributeGroup ref="ref"/>
   <xsd:attributeGroup ref="role">
    <xsd:annotation>
     <xsd:documentation>
      <h:div class="specific">
       <h:p>No formal semantics (yet). </h:p>
      </h:div>
     </xsd:documentation>
    </xsd:annotation>
   </xsd:attributeGroup>
   <xsd:attributeGroup ref="countExpression"/>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="fragmentList" id="el.fragmentList" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">A container for one or more fragments and joins.</h:div>
    <h:div class="description">
     <h:p>
      <h:tt>fragmentList</h:tt> can contain several fragments and joins. The normal content model is 
      <h:pre> join fragment join fragment... </h:pre>
     </h:p>
    </h:div>
    <h:div class="example" href="fragmentList1.xml"/>
    <h:div class="curation">2006-07-20: PMR Added</h:div>
    <h:div class="curation">2007-01-03: PMR Added role attribute</h:div>
   </xsd:documentation>
  </xsd:annotation>
  <xsd:complexType>
   <xsd:annotation>
    <xsd:documentation> </xsd:documentation>
   </xsd:annotation>
   <xsd:choice minOccurs="0" maxOccurs="unbounded">
    <xsd:element ref="metadataList"/>
    <xsd:element ref="join"/>
    <xsd:element ref="label"/>
    <xsd:element ref="fragment"/>
   </xsd:choice>
   <xsd:attributeGroup ref="dictRef"/>
   <xsd:attributeGroup ref="convention"/>
   <xsd:attributeGroup ref="title"/>
   <xsd:attributeGroup ref="id"/>
   <xsd:attributeGroup ref="ref"/>
   <xsd:attributeGroup ref="role"/>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="gradient" id="el.gradient" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">A gradient.</h:div>
    <h:div class="description">A container for a quantity or quantities representing the gradient of other quantities. At present just takes a scalar child.</h:div>
    <h:div class="example" href="gradient1.xml"/>
   </xsd:documentation>
  </xsd:annotation>
  <xsd:complexType>
   <xsd:sequence>
    <xsd:choice minOccurs="0" maxOccurs="unbounded">
     <xsd:element ref="scalar"/>
     <xsd:element ref="array"/>
     <xsd:element ref="matrix"/>
     <xsd:element ref="property"/>
    </xsd:choice>
   </xsd:sequence>
   <xsd:attributeGroup ref="title"/>
   <xsd:attributeGroup ref="id"/>
   <xsd:attributeGroup ref="convention"/>
   <xsd:attributeGroup ref="dictRef"/>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="identifier" id="el.identifier" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">A structured identifier.</h:div>
    <h:div class="description">
     <h:p>Supports compund identifiers such as IChI. At present uses the V0.9 IChI XML representation verbatim but will almost certainly change with future IChIs. </h:p>
     <h:p>The inclusion of elements from other namespaces causes problems with validation. The content model is deliberately LAX but the actual elements in IChI will fail the validation as they are not declared in CML.</h:p> For simple scalar values the value attribute can be used with empty content. Where an identifier has several components a series of label elements can be used.
    </h:div>
    <h:div class="curation">2003-07-10: Fixed count on identifier children..</h:div>
    <h:div class="curation">2003-03-12: Added isotopic and atoms..</h:div>
    <h:div class="example" href="identifier1.xml"/>
   </xsd:documentation>
  </xsd:annotation>
  <xsd:complexType>
   <!-- to avoid problems as IChI structure is updated -->
   <xsd:sequence maxOccurs="unbounded" minOccurs="0">
    <xsd:any processContents="lax"/>
   </xsd:sequence>
   <xsd:attributeGroup ref="value"/>
   <xsd:attributeGroup ref="version"/>
   <xsd:attributeGroup ref="title"/>
   <xsd:attributeGroup ref="id"/>
   <xsd:attributeGroup ref="convention"/>
   <xsd:attributeGroup ref="dictRef"/>
   <xsd:attributeGroup ref="tautomeric"/>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="integer" id="el.integer" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">CML-1 dataType DEPRECATED.</h:div>
    <h:div class="description"/>
    <h:div class="example" href="../../examples/cmlone.xml"/>
   </xsd:documentation>
  </xsd:annotation>
  <xsd:complexType>
   <xsd:simpleContent>
    <xsd:extension base="xsd:integer">
     <xsd:attributeGroup ref="builtin"/>
     <xsd:attributeGroup ref="convention"/>
     <xsd:attributeGroup ref="dictRef"/>
     <xsd:attributeGroup ref="id"/>
     <xsd:attributeGroup ref="title"/>
     <xsd:attributeGroup ref="min"/>
     <xsd:attributeGroup ref="max"/>
     <xsd:attributeGroup ref="units"/>
     <xsd:attributeGroup ref="unitsRef"/>
    </xsd:extension>
   </xsd:simpleContent>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="integerArray" id="el.integerArray" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">CML-1 dataType DEPRECATED.</h:div>
    <h:div class="description"/>
    <h:div class="example" href="../../examples/cmlone.xml"/>
   </xsd:documentation>
  </xsd:annotation>
  <xsd:complexType>
   <xsd:simpleContent>
    <xsd:extension base="xsd:string">
     <xsd:attributeGroup ref="builtin"/>
     <xsd:attributeGroup ref="convention"/>
     <xsd:attributeGroup ref="dictRef"/>
     <xsd:attributeGroup ref="id"/>
     <xsd:attributeGroup ref="title"/>
     <xsd:attributeGroup ref="min"/>
     <xsd:attributeGroup ref="max"/>
     <xsd:attributeGroup ref="size"/>
     <xsd:attributeGroup ref="units"/>
     <xsd:attributeGroup ref="unitsRef"/>
    </xsd:extension>
   </xsd:simpleContent>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="isotope" id="el.isotope" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">A specific isotope.</h:div>
    <h:div class="description">Defines an isotope in terms of exact mass and spin. Differentiate from isotopeList which defines a mixture of isotope.</h:div>
    <h:div class="example" href="isotope1.xml"/>
   </xsd:documentation>
  </xsd:annotation>
  <xsd:complexType>
   <xsd:sequence>
    <xsd:element ref="abundance" minOccurs="0" maxOccurs="1"/>
   </xsd:sequence>
   <xsd:attributeGroup ref="title"/>
   <xsd:attributeGroup ref="id"/>
   <xsd:attributeGroup ref="convention"/>
   <xsd:attributeGroup ref="dictRef"/>
   <xsd:attributeGroup ref="number"/>
   <xsd:attributeGroup ref="spin"/>
   <xsd:attributeGroup ref="elementType"/>
   <xsd:attributeGroup ref="ref"/>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="isotopeList" id="el.isotopeList" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">A container for one or more isotopes.</h:div>
    <h:div class="description">Can contain several isotopes. These may be related in several ways. This allows the definition of natural abundance and averged enrichment.</h:div>
    <h:div class="example" href="isotopeList1.xml"/>
   </xsd:documentation>
  </xsd:annotation>
  <xsd:complexType>
   <xsd:sequence>
    <xsd:element ref="isotope" minOccurs="0" maxOccurs="unbounded"/>
   </xsd:sequence>
   <xsd:attributeGroup ref="dictRef"/>
   <xsd:attributeGroup ref="convention"/>
   <xsd:attributeGroup ref="title"/>
   <xsd:attributeGroup ref="id"/>
   <xsd:attributeGroup ref="ref"/>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="join" id="el.join" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">Command to join two groups.</h:div>
    <h:div class="description"> EXPERIMENTAL. join will normally use atomRefs2 to identify 2 R atoms (i.e. elementType="R" that should be joined. The atoms to which the R atoms are attached are then joined by a new bond and the R groups are then deleted. It is currently an error if these atoms already have a connecting bond.</h:div>
    <h:div class="curation">2006-05-20: PMR added.</h:div>
    <h:div class="curation">2006-11-24: PMR deleted @left, @linkOnParent, @right, @repeat.</h:div>
    <h:div class="curation">2006-11-24: PMR modified content model</h:div>
    <h:div class="curation">2006-11-24: PMR added @moleculeRefs2</h:div>
   </xsd:documentation>
  </xsd:annotation>
  <xsd:complexType>
   <xsd:annotation>
    <xsd:documentation>
     <h:div class="summary"/>
    </xsd:documentation>
   </xsd:annotation>
   <xsd:sequence>
    <!-- <xsd:any minOccurs="0" maxOccurs="unbounded"/> -->
    <xsd:element ref="angle"/>
    <xsd:element ref="arg"/>
    <xsd:element ref="label"/>
    <xsd:element ref="length"/>
    <xsd:element ref="metadataList"/>
    <xsd:element ref="molecule"/>
    <xsd:element ref="torsion"/>
   </xsd:sequence>
   <xsd:attributeGroup ref="dictRef"/>
   <xsd:attributeGroup ref="convention"/>
   <xsd:attributeGroup ref="title"/>
   <xsd:attributeGroup ref="id"/>
   <xsd:attributeGroup ref="ref"/>
   <xsd:attributeGroup ref="atomRefs2"/>
   <xsd:attributeGroup ref="moleculeRefs2"/>
   <xsd:attributeGroup ref="order"/>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="kpoint" id="el.kpoint" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">A kpoint.</h:div>
    <h:div class="description">Not yet finalised.</h:div>
    <h:div class="example" href="kpoint1.xml"/>
    <h:div class="curation">2006-01-21: PMR. Created</h:div>
   </xsd:documentation>
  </xsd:annotation>
  <xsd:complexType>
   <xsd:simpleContent>
    <xsd:extension base="vector3Type">
     <xsd:attributeGroup ref="weight"/>
     <xsd:attributeGroup ref="label"/>
     <xsd:attributeGroup ref="title"/>
     <xsd:attributeGroup ref="id"/>
     <xsd:attributeGroup ref="convention"/>
     <xsd:attributeGroup ref="dictRef"/>
    </xsd:extension>
   </xsd:simpleContent>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="kpointList" id="el.kpointList" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">A container for kpoints.</h:div>
    <h:div class="description">Experimental.</h:div>
    <h:div class="example" href="kpoint1.xml"/>
   </xsd:documentation>
  </xsd:annotation>
  <xsd:complexType>
   <xsd:sequence>
    <xsd:choice minOccurs="0" maxOccurs="unbounded">
     <xsd:element ref="kpoint"/>
    </xsd:choice>
   </xsd:sequence>
   <xsd:attributeGroup ref="title"/>
   <xsd:attributeGroup ref="id"/>
   <xsd:attributeGroup ref="convention"/>
   <xsd:attributeGroup ref="dictRef"/>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="label" id="el.label" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">A text string qualifying an object.</h:div>
    <h:div class="description">A label can be used to identify or distinguish elements, add keywords or classifications and similar processes. It is usually interpretable by domain-aware humans (e.g. C3'-endo, but not a34561). It is usually either built in a semantically rich fashion (e.g. C2'-alpha-H) or belongs to a controlled vocabulary. It is possibly accessed by software in a domain-specific manner. It differs from 
     <h:tt>description</h:tt> which is free text. The distinction between titles, names and labels is fuzzy, but we think this is worth making. Labels may be necesssary to identify objects within programs, while names are more likely to be reserved for database searches. Titles are likely to be freer text and not recommended for precise object retrieval.
    </h:div>
    <h:div class="note">Labels should not contain whitespace. Punctuation marks are often necessary, but should not be gratuitously used. Punctuation clashing with XML character entities should be avoided; if this is not possible it should be escaped.</h:div>
    <h:div class="example" href="label1.xml">
     <h:em>From IUPAC Dictionary of Medicinal Chemistry</h:em>
    </h:div>
   </xsd:documentation>
  </xsd:annotation>
  <xsd:complexType>
   <xsd:sequence minOccurs="0" maxOccurs="unbounded">
    <xsd:any processContents="lax"/>
   </xsd:sequence>
   <xsd:attributeGroup ref="id"/>
   <xsd:attributeGroup ref="dictRef"/>
   <xsd:attributeGroup ref="value"/>
   <xsd:attributeGroup ref="objectClass"/>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="lattice" id="el.lattice" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">A lattice of dimension 3 or less.</h:div>
    <h:div class="description">Lattice is a general approach to describing periodic systems. It can have variable dimensionality or periodicity, and could be finite.</h:div>
    <h:div class="note"> _lattice_ is more general than _crystal_ in cmlCore which is used primarily for reporting crystallographic experiments.`A lattice can be described by latticeVectors, cell axes and angles, or metric tensors, etc. (only axes/angles are allowed under 
     <h:tt>crystal</h:tt>). The dimensionality is enforced through a _system_ parent element.
    </h:div>
    <h:div class="example" href="lattice3.xml"/>
   </xsd:documentation>
  </xsd:annotation>
  <xsd:complexType>
   <xsd:sequence>
    <xsd:choice>
     <xsd:element ref="scalar" minOccurs="3" maxOccurs="6">
      <xsd:annotation>
       <xsd:documentation>
        <h:div class="summary">All appropriate cell parameters must be given, even where angles are fixed by symmetry. The order is fixed as a,b,c,alpha,beta,gamma and software can neglect any title or dictRef attributes. Error estimates can be given if required. Any units can be used, but the defaults are Angstrom (10^-10 m) and degrees. To be developed for lower dimensionality.</h:div>
       </xsd:documentation>
      </xsd:annotation>
     </xsd:element>
     <xsd:element ref="latticeVector" minOccurs="1" maxOccurs="3">
      <!-- <h:div class="summary">A number of lattice vectors equal to the dimensionality. Note that some vectors may give rise to periodicty while others do not. Thus a surface can be described by two vector in the plane of the surface and one perpendicular to them.</h:div> -->
     </xsd:element>
     <xsd:element ref="matrix" minOccurs="1" maxOccurs="1">
      <!-- <h:div class="summary">The metric tensor (normally for 3 dimensions).</h:div> -->
     </xsd:element>
    </xsd:choice>
    <xsd:element ref="symmetry" minOccurs="0"/>
   </xsd:sequence>
   <xsd:attributeGroup ref="title"/>
   <xsd:attributeGroup ref="id"/>
   <xsd:attributeGroup ref="convention"/>
   <xsd:attributeGroup ref="dictRef"/>
   <xsd:attributeGroup ref="latticeType"/>
   <xsd:attributeGroup ref="spaceType"/>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="latticeVector" id="el.latticeVector" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">A vector3 representing a lattice axis.</h:div>
    <h:div class="description">a 
     <h:tt>lattice</h:tt> can be represented by 1-3 non-linearly dependent latticeVectors. If the dimensionality is less than 3 latticeVectors are the preferred method. Similarly, if the axes show a mixture of periodicity and non-periodicity latticeVectors can support this. The number of periodic vectors must correspond with the periodicity attribute on a 
     <h:tt>system</h:tt> element. 
     <h:p>The vector must not be zero and units must be given. (Zero vectors must not be used to reduce dimensionality). </h:p>
     <h:p>A lattice vector defaults to periodic.</h:p>.
    </h:div>
    <h:div class="description">Any or all of the axes may be periodic or aperiodic. An example could be a surface where 2 periodic axes (not necessarily orthogonal) are used to describe the coordinates in the surface, perhaps representing lattice vectors of a 3D crystal or 2D layer. The third vector is orthogonal and represents coordinates normal to the surface. In this case only the direction, not the magnitude of the vector is important.</h:div>
    <h:div class="example" href="latticeVector1.xml"/>
   </xsd:documentation>
  </xsd:annotation>
  <xsd:complexType>
   <xsd:simpleContent>
    <xsd:extension base="vector3Type">
     <xsd:attributeGroup ref="convention"/>
     <xsd:attributeGroup ref="dictRef"/>
     <xsd:attributeGroup ref="id"/>
     <xsd:attributeGroup ref="title"/>
     <xsd:attributeGroup ref="units"/>
     <xsd:attributeGroup ref="periodic"/>
    </xsd:extension>
   </xsd:simpleContent>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="length" id="el.length" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">A length between two atoms.</h:div>
    <h:div class="general">This is either an experimental measurement or used to build up internal coordinates (as in a z-matrix) (only one allowed). We expect to move length as a child of _molecule_ and remove it from here.</h:div>
    <h:div class="example" href="length1.xml"/>
   </xsd:documentation>
  </xsd:annotation>
  <xsd:complexType>
   <xsd:simpleContent>
    <xsd:extension base="xsd:double">
     <xsd:attributeGroup ref="title"/>
     <xsd:attributeGroup ref="id"/>
     <xsd:attributeGroup ref="convention"/>
     <xsd:attributeGroup ref="dictRef"/>
     <xsd:attributeGroup ref="atomRefs2"/>
     <xsd:attributeGroup ref="units"/>
     <xsd:attributeGroup ref="errorValue"/>
     <xsd:attributeGroup ref="errorBasis"/>
     <xsd:attributeGroup ref="min"/>
     <xsd:attributeGroup ref="max"/>
     <xsd:attributeGroup ref="ref"/>
    </xsd:extension>
   </xsd:simpleContent>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="line3" id="el.line3" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">A line in 3-space.</h:div>
    <h:div class="description">A line characterised by one or two endpoints.</h:div>
    <h:div class="curation">2006-01-02: the 6-number content has caused much confusion and will be obsoleted in favour of the point3 and vector3 attributes</h:div>
   </xsd:documentation>
  </xsd:annotation>
  <xsd:complexType>
   <xsd:simpleContent>
    <xsd:extension base="line3Type">
     <xsd:attributeGroup ref="convention"/>
     <xsd:attributeGroup ref="dictRef"/>
     <xsd:attributeGroup ref="id"/>
     <xsd:attributeGroup ref="title"/>
     <xsd:attributeGroup ref="units"/>
     <xsd:attributeGroup ref="point3"/>
     <xsd:attributeGroup ref="vector3"/>
    </xsd:extension>
   </xsd:simpleContent>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="link" id="el.link" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">An internal or external link to other objects.</h:div>
    <h:div class="description">
     <h:p>
      <h:b>Semantics are similar to XLink, but simpler and only a subset is implemented.</h:b> This is intended to make the instances easy to create and read, and software relatively easy to implement. The architecture is:
     </h:p>
     <h:ul>
      <h:li>
       <h:b>A single element (
        <h:tt>link</h:tt>) used for all linking purposes.
       </h:b>
      </h:li>
      <h:li>
       <h:b>The link types are determined by the 
        <h:tt>type</h:tt> attribute and can be:
       </h:b>. 
       <h:ul>
        <h:li>
         <h:b>locator</h:b>. This points to a single target and must carry either a 
         <h:tt>ref</h:tt> or 
         <h:tt>href</h:tt> attribute. 
         <h:tt>locator</h:tt> links are usually children of an extended link. 
         <h:li>
          <h:b>arc</h:b>. This is a 1:1 link with both ends (
          <h:tt>from</h:tt> and 
          <h:tt>to</h:tt>) defined.
         </h:li>
         <h:li>
          <h:b>extended</h:b>. This is usually a parent of several locator links and serves to create a grouping of link ends (i.e. a list of references in documents).
         </h:li> Many-many links can be built up from arcs linking extended elements
        </h:li>
       </h:ul>
       <h:p>All links can have optional 
        <h:tt>role</h:tt> attributes. The semantics of this are not defined; you are encouraged to use a URI as described in the XLink specification.
       </h:p>
       <h:p>There are two address spaces: </h:p>
       <h:ul>
        <h:li>The 
         <h:tt>href</h:tt> attribute on locators behaves in the same way as 
         <h:tt>href</h:tt> in HTML and is of type 
         <h:tt>xsd:anyURI</h:tt>. Its primary use is to use XPointer to reference elements outside the document.
        </h:li>
        <h:li>The 
         <h:tt>ref</h:tt> attribute on locators and the 
         <h:tt>from</h:tt> and 
         <h:tt>to</h:tt> attributes on 
         <h:tt>arc</h:tt>s refer to IDs (
         <h:em>without</h:em> the '#' syntax).
        </h:li>
       </h:ul>
       <h:p>Note: several other specific linking mechanisms are defined elsewhere in STM. 
        <h:a href="el.relatedEntry">relatedEntry</h:a> should be used in dictionaries, and 
        <h:a href="st.dictRef">dictRef</h:a> should be used to link to dictionaries. There are no required uses of 
        <h:tt>link</h:tt> in STMML but we have used it to map atoms, electrons and bonds in reactions in CML
       </h:p>
      </h:li>
     </h:ul>
     <h:p>
      <h:b>Relation to XLink</h:b>. At present (2002) we are not aware of generic XLink processors from which we would benefit, so the complete implementation brings little extra value. Among the simplifications from Xlink are:
     </h:p>
     <h:ul>
      <h:li>
       <h:tt>type</h:tt> supports only 
       <h:tt>extended</h:tt>, 
       <h:tt>locator</h:tt> and 
       <h:tt>arc</h:tt>
      </h:li>
      <h:li>
       <h:tt>label</h:tt> is not supported and 
       <h:tt>id</h:tt>s are used as targets of links.
      </h:li>
      <h:li>
       <h:tt>show</h:tt> and 
       <h:tt>actuate</h:tt> are not supported.
      </h:li>
      <h:li>
       <h:tt>xlink:title</h:tt> is not supported (all STM elements can have a 
       <h:tt>title</h:tt> attribute).
      </h:li>
      <h:li>
       <h:tt>xlink:role</h:tt> supports any string (i.e. does not have to be a namespaced resource). This mechanism can, of course, still be used and we shall promote it where STM benefits from it
      </h:li>
      <h:li>The 
       <h:tt>to</h:tt> and 
       <h:tt>from</h:tt> attributes point to IDs rather than labels
      </h:li>
      <h:li>The xlink namespace is not used</h:li>
      <h:li>It is not intended to create independent linkbases, although some collections of links may have this property and stand outside the documents they link to</h:li>
     </h:ul>
    </h:div>
   </xsd:documentation>
  </xsd:annotation>
  <xsd:complexType>
   <xsd:sequence>
    <xsd:any minOccurs="0" maxOccurs="unbounded"/>
   </xsd:sequence>
   <xsd:attributeGroup ref="title"/>
   <xsd:attributeGroup ref="id"/>
   <xsd:attributeGroup ref="convention"/>
   <xsd:attributeGroup ref="dictRef"/>
   <xsd:attributeGroup ref="from"/>
   <xsd:attributeGroup ref="to"/>
   <xsd:attributeGroup ref="ref"/>
   <xsd:attributeGroup ref="fromType">
    <xsd:annotation>
     <xsd:documentation>
      <h:div class="specific">The type of the object/element in the 'from' attributes. Requires the objects referenced by the 'from' attributes to have a given elementType. Can be overridden by 'from' attributes in individual links. 2005-06-18: created</h:div>
     </xsd:documentation>
    </xsd:annotation>
   </xsd:attributeGroup>
   <xsd:attributeGroup ref="toType">
    <xsd:annotation>
     <xsd:documentation>
      <h:div class="specific">The type of the object/element in the 'to' attributes. Requires the objects referenced by the 'to' attributes to have a given elementType. Can be overridden by 'to' attributes in individual links. 2005-06-18: created</h:div>
     </xsd:documentation>
    </xsd:annotation>
   </xsd:attributeGroup>
   <xsd:attributeGroup ref="fromSet">
    <xsd:annotation>
     <xsd:documentation>
      <h:div class="specific">The set of ids in the base of the link. 2005-06-18: created</h:div>
     </xsd:documentation>
    </xsd:annotation>
   </xsd:attributeGroup>
   <xsd:attributeGroup ref="toSet">
    <xsd:annotation>
     <xsd:documentation>
      <h:div class="specific">The set of ids in the target of the link. 2005-06-18: created</h:div>
     </xsd:documentation>
    </xsd:annotation>
   </xsd:attributeGroup>
   <xsd:attributeGroup ref="fromContext">
    <xsd:annotation>
     <xsd:documentation>
      <h:div class="specific">The id of the ancestral element of objects referenced by 'from' attributes. Provides a context for uniquifying the references in the 'from' attributes. Thus atoms referenced by ids should be unique within a given molecule and the id of this could be the 'fromContext'. 2005-06-18: created</h:div>
     </xsd:documentation>
    </xsd:annotation>
   </xsd:attributeGroup>
   <xsd:attributeGroup ref="toContext">
    <xsd:annotation>
     <xsd:documentation>
      <h:div class="specific">The id of the ancestral element of objects referenced by 'to' attributes. Provides a context for uniquifying the references in the 'to' attributes. Thus atoms referenced by ids should be unique within a given molecule and the id of this could be the 'toContext'. 2005-06-18: created</h:div>
     </xsd:documentation>
    </xsd:annotation>
   </xsd:attributeGroup>
   <xsd:attributeGroup ref="role">
    <xsd:annotation>
     <xsd:documentation>
      <h:div class="specific">The role of the link. Xlink adds semantics through a URI; we shall not be this strict. We shall not normally use this mechanism and use dictionaries instead.</h:div>
     </xsd:documentation>
    </xsd:annotation>
   </xsd:attributeGroup>
   <xsd:attributeGroup ref="href">
    <xsd:annotation>
     <xsd:documentation>
      <h:div class="specific">The target of the (locator) link, outside the document.</h:div>
     </xsd:documentation>
    </xsd:annotation>
   </xsd:attributeGroup>
   <xsd:attributeGroup ref="linkType"/>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="list" id="el.list" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">A generic container with no implied semantics.</h:div>
    <h:div class="description">A generic container with no implied semantics. It just contains things and can have attributes which bind conventions to it. It could often act as the root element in an STM document.</h:div>
    <h:div class="example" href="list1.xml"/>
   </xsd:documentation>
  </xsd:annotation>
  <xsd:complexType>
   <xsd:sequence>
    <xsd:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
   </xsd:sequence>
   <xsd:attributeGroup ref="title"/>
   <xsd:attributeGroup ref="id"/>
   <xsd:attributeGroup ref="convention"/>
   <xsd:attributeGroup ref="dictRef"/>
   <xsd:attributeGroup ref="type"/>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="map" id="el.map" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">A container for links</h:div>
    <h:div class="description">
     <h:p>Usage is now standardized with map as the container and link as the individual links. The links are often effectively typed pointers to other parts of the document. The type can be set for all links by the 'fromType' and 'toType' attributes, either in the map, which then applied to all links by default, or in individual links, when it overrides the map setting. Since ids may not be unique within a document the refs can be given context with the 'fromRef' and 'toRef' attributes in the map element. If more than one context is used it may be better to use multiple maps. The role of map, and its relationship to RDF is still being developed. </h:p>
     <h:p> Currently (2005) map has primarily been used to map atoms between reactants and products, but we also expect shortly to extend it to peak assignments and several otherr areas. A map consists of a number of links, which can be directional, relating two elements through their ids. Reference is through the mandatory 'to' and 'from' attributes which must point to existing id attributes on elements. The type of the dereferenced element can be specified in 'toType' and 'fromType' which, while redundant, is an aid to software and acts as a check on referential type integrity. </h:p>
     <h:p> In principle any element can be linked to any other, with 1:1, 1:n, and n:m topology. We expect maps to be used for precise chemical concepts such as reactions, peak assignments, electron management, molecular superpositions, etc. and that these are supported by bespoke code. For other links, especially with complex topology, users should consider whether RDF may be more appropriate. </h:p>
     <h:p>In some cases partial mapping is known (e.g. one set of atoms maps to another set), but the precise links are unknown. (This is not the same as n:m mapping where n*m precise links would be expected). In some cases there may be objects such as atomSets or peakGroups which could be linked to support this. Alternatively the 'fromSet' and 'toSet' attributes can be used to hold a list of ids. Thus from='a1 a2' to='b3 b4' might imply that there were two precise links (either {a1=&gt;b3, a2=&gt;b4} or {a1=&gt;b4, a2=&gt;b3}). This is most likely to be used in intermediate documents where more precise semantics can be added later. The ids must all refer to elements of the same type. Note that a 'to' link referencing a single atomSet (toType='atomSet') is not the same as a 'toSet' of toType='atom' with multiple atomIds. The first would require an 'atomSet' element in the document; the second would not. The precise semantics such as the order of ids are application-dependent. If the order is known in both the toSet and fromSet then individual links should be used rather than adding the burden of deconstruction on the implementer. </h:p>
    </h:div>
    <h:div class="curation">2005-06-18: added typing and role and updated docs.</h:div>
    <h:div class="curation">2006-08-05: added ref attribute.</h:div>
   </xsd:documentation>
  </xsd:annotation>
  <xsd:complexType>
   <xsd:sequence minOccurs="0" maxOccurs="unbounded">
    <xsd:element ref="link"/>
   </xsd:sequence>
   <xsd:attributeGroup ref="title"/>
   <xsd:attributeGroup ref="id"/>
   <xsd:attributeGroup ref="convention"/>
   <xsd:attributeGroup ref="dictRef"/>
   <xsd:attributeGroup ref="ref"/>
   <xsd:attributeGroup ref="fromType">
    <xsd:annotation>
     <xsd:documentation>
      <h:div class="specific">The type of the object/element in the 'from' attributes. Requires the objects referenced by the 'from' attributes to have a given elementType. Can be overridden by 'from' attributes in individual links. 2005-06-18: created</h:div>
     </xsd:documentation>
    </xsd:annotation>
   </xsd:attributeGroup>
   <xsd:attributeGroup ref="toType">
    <xsd:annotation>
     <xsd:documentation>
      <h:div class="specific">The type of the object/element in the 'to' attributes. Requires the objects referenced by the 'to' attributes to have a given elementType. Can be overridden by 'to' attributes in individual links. 2005-06-18: created</h:div>
     </xsd:documentation>
    </xsd:annotation>
   </xsd:attributeGroup>
   <xsd:attributeGroup ref="fromContext">
    <xsd:annotation>
     <xsd:documentation>
      <h:div class="specific">The id of the ancestral element of objects referenced by 'from' attributes. Provides a context for uniquifying the references in the 'from' attributes. Thus atoms referenced by ids should be unique within a given molecule and the id of this could be the 'fromContext'. 2005-06-18: created</h:div>
     </xsd:documentation>
    </xsd:annotation>
   </xsd:attributeGroup>
   <xsd:attributeGroup ref="toContext">
    <xsd:annotation>
     <xsd:documentation>
      <h:div class="specific">The id of the ancestral element of objects referenced by 'to' attributes. Provides a context for uniquifying the references in the 'to' attributes. Thus atoms referenced by ids should be unique within a given molecule and the id of this could be the 'toContext'. 2005-06-18: created</h:div>
     </xsd:documentation>
    </xsd:annotation>
   </xsd:attributeGroup>
   <xsd:attributeGroup ref="role">
    <xsd:annotation>
     <xsd:documentation>
      <h:div class="specific">The role of the map. Semantics are undefined, and can be used to provide a small semi-controlled vocabulary for identifying maps of different types. 2005-06-18: created</h:div>
     </xsd:documentation>
    </xsd:annotation>
   </xsd:attributeGroup>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="matrix" id="el.matrix" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">A rectangular matrix of any quantities.</h:div>
    <h:div class="description">
     <h:p>By default 
      <h:tt>matrix</h:tt> represents a rectangular matrix of any quantities representable as XSD or STMML dataTypes. It consists of 
      <h:tt>rows*columns</h:tt> elements, where 
      <h:tt>columns</h:tt> is the fasting moving index. Assuming the elements are counted from 1 they are ordered 
      <h:tt>V[1,1],V[1,2],...V[1,columns],V[2,1],V[2,2],...V[2,columns], ...V[rows,1],V[rows,2],...V[rows,columns]</h:tt>
     </h:p>
     <h:p>By default whitespace is used to separate matrix elements; see 
      <h:a href="el.array">array</h:a> for details. There are NO characters or markup delimiting the end of rows; authors must be careful!. The 
      <h:tt>columns</h:tt> and 
      <h:tt>rows</h:tt> attributes have no default values; a row vector requires a 
      <h:tt>rows</h:tt> attribute of 1.
     </h:p>
     <h:p>
      <h:tt>matrix</h:tt> also supports many types of square matrix, but at present we require all elements to be given, even if the matrix is symmetric, antisymmetric or banded diagonal. The 
      <h:tt>matrixType</h:tt> attribute allows software to validate and process the type of matrix.
     </h:p>
    </h:div>
    <h:div class="example" href="matrix1.xml"/>
   </xsd:documentation>
  </xsd:annotation>
  <xsd:complexType>
   <xsd:simpleContent>
    <xsd:extension base="xsd:string">
     <xsd:attributeGroup ref="dataType"/>
     <xsd:attributeGroup ref="delimiter"/>
     <xsd:attributeGroup ref="rows"/>
     <xsd:attributeGroup ref="columns"/>
     <xsd:attributeGroup ref="units"/>
     <xsd:attributeGroup ref="title"/>
     <xsd:attributeGroup ref="id"/>
     <xsd:attributeGroup ref="convention"/>
     <xsd:attributeGroup ref="dictRef"/>
     <xsd:attributeGroup ref="matrixType"/>
     <xsd:attributeGroup ref="errorValueArray"/>
     <xsd:attributeGroup ref="errorBasis"/>
     <xsd:attributeGroup ref="minValueArray"/>
     <xsd:attributeGroup ref="maxValueArray"/>
    </xsd:extension>
   </xsd:simpleContent>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="mechanism" id="el.mechanism" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">The mechanism of a reaction.</h:div>
    <h:div class="description">
     <h:p>In some cases this may be a simple textual description or reference within a controlled vocabulary. In others it may describe the complete progress of the reaction, including topological or cartesian movement of atoms, bonds and electrons and annotation with varying quantities (e.g. energies). </h:p>
     <h:p> For named reaction mechanisms ("Diels-Alder", "ping-pong", "Claisen rearrangement", etc.) the 
      <h:tt>name</h:tt> element should be used. For classification (e.g. "hydrolysis"), the 
      <h:tt>label</h:tt> may be more appropriate. 
     </h:p>
     <h:p>In more detailed cases the mechanism refers to components of the 
      <h:tt>reaction</h:tt> element. Thus bond23 might be cleaved while bond19 is transformed (mapped) to bond99. The 
      <h:tt>mechanismComponent</h:tt> can be used to refer to components and add annotation. This is still experimental.
     </h:p>
    </h:div>
    <h:div class="description">
     <h:p>IUPAC Compendium of Chemical Terminology 2nd Edition (1997) describes a mechanism as: 
      <h:blockquote>A detailed description of the process leading from the reactants to the products of a reaction, including a characterization as complete as possible of the composition, structure, energy and other properties of reaction intermediates, products and transition states. An acceptable mechanism of a specified reaction (and there may be a number of such alternative mechanisms not excluded by the evidence) must be consistent with the reaction stoichiometry, the rate law and with all other available experimental data, such as the stereochemical course of the reaction. Inferences concerning the electronic motions which dynamically interconvert successive species along the reaction path (as represented by curved arrows, for example) are often included in the description of a mechanism. It should be noted that for many reactions all this information is not available and the suggested mechanism is based on incomplete experimental data. It is not appropriate to use the term mechanism to describe a statement of the probable sequence in a set of stepwise reactions. That should be referred to as a reaction sequence, and not a mechanism.</h:blockquote>
     </h:p>
     <h:p>CMLReact provides reactionScheme and annotions to describe the reaction sequence and both it and 
      <h:tt>mechanism</h:tt> could co-occur within a reactionScheme container.
     </h:p>
    </h:div>
    <h:div class="curation">2006-02-28 PMR: changed content model to choice.</h:div>
    <h:div class="example" href="mechanism1.xml"/>
   </xsd:documentation>
  </xsd:annotation>
  <xsd:complexType>
   <xsd:choice minOccurs="0" maxOccurs="unbounded">
    <xsd:element ref="name"/>
    <xsd:element ref="label"/>
    <xsd:element ref="description"/>
    <xsd:element ref="mechanismComponent"/>
   </xsd:choice>
   <xsd:attributeGroup ref="title"/>
   <xsd:attributeGroup ref="id"/>
   <xsd:attributeGroup ref="convention"/>
   <xsd:attributeGroup ref="dictRef"/>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="mechanismComponent" id="el.mechanismComponent" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">An information component within a reaction mechanism.</h:div>
    <h:div class="description">
     <h:p>Information components can represent both physical constituents of the reaction or abstract concepts (types of bond cleavage, thermodynamics, etc.). There are several ways that components of the reaction can be annotated and/or quantified. One approach will be to refer to specific bonds and atoms through their ids and use mechanismComponent to describe their role, properties, etc. Another is to use mechanismComponent to identify types of bond formed/broken without reference to actual atoms and bonds (initially through the 
      <h:tt>name</h:tt> element). Yet another will be to include information on the reaction profile.
     </h:p>
     <h:p> This is still experimental.</h:p>
    </h:div>
    <h:div class="example" href="mechanismComponent1.xml"/>
   </xsd:documentation>
  </xsd:annotation>
  <xsd:complexType>
   <xsd:sequence>
    <xsd:any processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
   </xsd:sequence>
   <xsd:attributeGroup ref="title"/>
   <xsd:attributeGroup ref="id"/>
   <xsd:attributeGroup ref="convention"/>
   <xsd:attributeGroup ref="dictRef"/>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="metadata" id="el.metadata" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">A general container for metadata.</h:div>
    <h:div class="description">
     <h:p>A general container for metadata, including at least Dublin Core (DC) and CML-specific metadata</h:p>
     <h:p>In its simple form each element provides a name and content in a similar fashion to the 
      <h:tt>meta</h:tt> element in HTML. 
      <h:tt>metadata</h:tt> may have simpleContent (i.e. a string for adding further information - this is not controlled).
     </h:p>
    </h:div>
    <h:div class="example" href="metadata1.xml"/>
   </xsd:documentation>
  </xsd:annotation>
  <xsd:complexType>
   <xsd:simpleContent>
    <xsd:extension base="xsd:string">
     <xsd:attributeGroup ref="content"/>
     <xsd:attributeGroup ref="convention"/>
     <xsd:attributeGroup ref="dictRef"/>
     <xsd:attributeGroup ref="id"/>
     <!-- this creates an attribute of name "name" -->
     <xsd:attributeGroup ref="metadataType"/>
     <xsd:attributeGroup ref="title"/>
    </xsd:extension>
   </xsd:simpleContent>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="metadataList" id="el.metadataList" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">A general container for metadata elements.</h:div>
    <h:div class="description">MetadataLists can have local roles (e.g. a bibliographic reference could be a single meteadatList with, say, 3-6 components). The role attribute is used in an uncontrolled manner for this. MetadataLists can also be nested, but metadata and metadataList children should not occur on the same level of the hierarchy.</h:div>
    <h:div class="example" href="metadata1.xml"/>
   </xsd:documentation>
  </xsd:annotation>
  <xsd:complexType>
   <xsd:choice minOccurs="0" maxOccurs="unbounded">
    <xsd:element ref="metadataList"/>
    <xsd:element ref="metadata"/>
   </xsd:choice>
   <xsd:attributeGroup ref="id"/>
   <xsd:attributeGroup ref="title"/>
   <xsd:attributeGroup ref="convention"/>
   <xsd:attributeGroup ref="dictRef"/>
   <xsd:attributeGroup ref="name"/>
   <xsd:attributeGroup ref="role"/>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="module" id="el.module" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">A module in a calculation.</h:div>
    <h:div class="description">
     <h:p>Many programs are based on discrete modules which produce chunks of output. There are also conceptual chunks such as initialisation, calculation and summary/final which often have finer submodules such as cycle, iteration, snapshot, etc. There is no controlled vocabulary but a typical structure is shown in the example. One of the challenges of CCML is to find communality between different programs and to use agreed abstractions for the modules. </h:p>
    </h:div>
    <h:div class="example" href="module1.xml"/>
   </xsd:documentation>
  </xsd:annotation>
  <xsd:complexType>
   <xsd:sequence>
    <xsd:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
   </xsd:sequence>
   <xsd:attributeGroup ref="serial"/>
   <xsd:attributeGroup ref="title"/>
   <xsd:attributeGroup ref="id"/>
   <xsd:attributeGroup ref="convention"/>
   <xsd:attributeGroup ref="dictRef"/>
   <xsd:attributeGroup ref="role">
    <xsd:annotation>
     <xsd:documentation>
      <h:div class="specific">The module can have a program-specific name through its title or dictRef (e.g. "MINIM", "l201") and a generic role ("dynamicsCalculation", "equilibration", etc.). In general role will be controlled by CCML.</h:div>
     </xsd:documentation>
    </xsd:annotation>
   </xsd:attributeGroup>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="molecule" id="el.molecule" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">A container for atoms, bonds and submolecules.</h:div>
    <h:div class="description">
     <h:p>
      <h:tt>molecule</h:tt> is a container for atoms, bonds and submolecules along with properties such as crystal and non-builtin properties. It should either contain 
      <h:tt>molecule</h:tt> or *Array for atoms and bonds. A molecule can be empty (e.g. we just know its name, id, etc.)
     </h:p>
     <h:p>"Molecule" need not represent a chemically meaningful molecule. It can contain atoms with bonds (as in the solid-sate) and it could simply carry a name (e.g. "taxol") without formal representation of the structure. It can contain "sub molecules", which are often discrete subcomponents (e.g. guest-host).</h:p>
     <h:p>Molecule can contain a &lt;list&gt; element to contain data related to the molecule. Within this can be string/float/integer and other nested lists</h:p>
    </h:div>
    <h:div>
     <h:p>Normally molecule will not contain fragment or fragmentList</h:p>
    </h:div>
    <h:div class="example" href="molecule1.xml"/>
    <h:div class="curation">Revised content model to allow any order of lengths, angles, torsions 2003-01-01..</h:div>
    <h:div class="curation">Added role attribute 2003-03-19..</h:div>
    <h:div class="curation">2006-05-21. PMR changed content model to (A|B|C...)*</h:div>
    <h:div class="curation">2006-11-24. PMR removed @tail, @head, @countExpression, @repeat</h:div>
   </xsd:documentation>
  </xsd:annotation>
  <xsd:complexType>
   <xsd:annotation>
    <xsd:documentation>
     <h:div class="summary">The float|integer|string children are for compatibility with CML-1 and are deprecated. scalar|array|matrix should be used instead.</h:div>
    </xsd:documentation>
   </xsd:annotation>
   <xsd:sequence>
    <xsd:choice minOccurs="0" maxOccurs="unbounded">
     <xsd:element ref="angle"/>
     <xsd:element ref="arg"/>
     <xsd:element ref="array"/>
     <xsd:element ref="atomArray"/>
     <xsd:element ref="bondArray"/>
     <xsd:element ref="crystal"/>
     <xsd:element ref="electron"/>
     <xsd:element ref="formula"/>
     <xsd:element ref="identifier"/>
     <xsd:element ref="join"/>
     <xsd:element ref="label"/>
     <xsd:element ref="length"/>
     <xsd:element ref="list"/>
     <xsd:element ref="matrix"/>
     <xsd:element ref="metadataList"/>
     <xsd:element ref="molecule"/>
     <xsd:element ref="name"/>
     <xsd:element ref="propertyList"/>
     <xsd:element ref="scalar"/>
     <xsd:element ref="symmetry"/>
     <xsd:element ref="torsion"/>
     <xsd:element ref="zMatrix"/>
    </xsd:choice>
   </xsd:sequence>
   <xsd:attributeGroup ref="dictRef"/>
   <xsd:attributeGroup ref="convention"/>
   <xsd:attributeGroup ref="title"/>
   <xsd:attributeGroup ref="id"/>
   <xsd:attributeGroup ref="ref"/>
   <xsd:attributeGroup ref="idgen"/>
   <xsd:attributeGroup ref="process"/>
   <xsd:attributeGroup ref="formula"/>
   <xsd:attributeGroup ref="count"/>
   <xsd:attributeGroup ref="chirality"/>
   <xsd:attributeGroup ref="formalCharge"/>
   <xsd:attributeGroup ref="spinMultiplicity"/>
   <xsd:attributeGroup ref="symmetryOriented"/>
   <xsd:attributeGroup ref="role">
    <xsd:annotation>
     <xsd:documentation>
      <h:div class="specific">
       <h:p>No formal semantics (yet). The role describes the purpose of the molecule element at this stage in the information. Examples can be "conformation", "dynamicsStep", "vibration", "valenceBondIsomer", etc. This attribute may be used by applications to determine how to present a set of molecule elements.</h:p>
      </h:div>
     </xsd:documentation>
    </xsd:annotation>
   </xsd:attributeGroup>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="moleculeList" id="el.moleculeList" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">A container for one or more molecules.</h:div>
    <h:div class="description">
     <h:p>
      <h:tt>moleculeList</h:tt> can contain several molecules. These may be related in many ways and there is are controlled semantics. However it should not be used for a molecule consisting of descendant molecules for which molecule should be used. A moleculeList can contain nested moleculeLists. 
     </h:p>
    </h:div>
    <h:div class="example" href="moleculeList1.xml"/>
    <h:div class="curation">2006-07-20: PMR Added</h:div>
   </xsd:documentation>
  </xsd:annotation>
  <xsd:complexType>
   <xsd:annotation>
    <xsd:documentation>
     <h:div>
      <h:tt>metadataList</h:tt> contains 
      <h:tt>metadata</h:tt>. 
      <h:tt>list</h:tt> is for experimental and other data. 
      <h:tt>moleculeList</h:tt> normally contains 
      <h:tt>molecule</h:tt>s but we make provision for nested moleculeLists if required. The 
      <h:tt>molecule</h:tt>s can be a set of reference molecules which occur in the 
      <h:tt>molecule</h:tt>s and can be referenced. This makes the molecules more readable and normalizes data when molecules are used more than once.
     </h:div>
    </xsd:documentation>
   </xsd:annotation>
   <xsd:sequence>
    <xsd:element ref="metadataList" minOccurs="0" maxOccurs="unbounded"/>
    <xsd:element ref="list" minOccurs="0" maxOccurs="unbounded"/>
    <xsd:choice>
     <xsd:element ref="moleculeList" minOccurs="0" maxOccurs="unbounded"/>
     <xsd:element ref="molecule" minOccurs="0" maxOccurs="unbounded"/>
    </xsd:choice>
   </xsd:sequence>
   <xsd:attributeGroup ref="dictRef"/>
   <xsd:attributeGroup ref="convention"/>
   <xsd:attributeGroup ref="title"/>
   <xsd:attributeGroup ref="id"/>
   <xsd:attributeGroup ref="ref"/>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="name" id="el.name" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">A string identifying a object.</h:div>
    <h:div class="description">
     <h:tt>name</h:tt> is used for chemical names (formal and trivial) for molecules and also for identifiers such as CAS registry and RTECS. It can also be used for labelling atoms. It should be used in preference to the 
     <h:tt>title</h:tt> attribute because it is repeatable and can be linked to a dictionary. 
     <h:p>Constraining patterns can be described in the dictionary and used to validate 
      <h:tt>name</h:tt>s.
     </h:p>
    </h:div>
    <h:div class="example" href="name1.xml"/>
   </xsd:documentation>
  </xsd:annotation>
  <xsd:complexType>
   <xsd:simpleContent>
    <xsd:extension base="xsd:string">
     <xsd:attributeGroup ref="id"/>
     <xsd:attributeGroup ref="convention"/>
     <xsd:attributeGroup ref="dictRef"/>
    </xsd:extension>
   </xsd:simpleContent>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="object" id="el.object" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">An object which might occur in scientific data or narrative.</h:div>
    <h:div class="description">Deliberately vague. Thus an instrument might be built from sub component objects, or a program could be composed of smaller modules (objects). 
     <h:tt>object</h:tt> could be used to encapsulate graphical primitives (e.g. in reaction schemes, drawings of apparatus, etc.). Unrestricted content model.
    </h:div>
    <h:div class="example" href="object1.xml"/>
   </xsd:documentation>
  </xsd:annotation>
  <xsd:complexType mixed="true">
   <xsd:sequence minOccurs="0" maxOccurs="unbounded">
    <xsd:any processContents="lax"/>
   </xsd:sequence>
   <xsd:attributeGroup ref="title"/>
   <xsd:attributeGroup ref="id"/>
   <xsd:attributeGroup ref="convention"/>
   <xsd:attributeGroup ref="dictRef"/>
   <xsd:attributeGroup ref="name"/>
   <xsd:attributeGroup ref="type"/>
   <xsd:attributeGroup ref="count"/>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="observation" id="el.observation" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">An observation or occurrence.</h:div>
    <h:div class="description">A container for any events that need to be recorded, whether planned or not. They can include notes, measurements, conditions that may be referenced elsewhere, etc. There are no controlled semantics.</h:div>
    <h:div class="example" href="observation1.xml"/>
   </xsd:documentation>
  </xsd:annotation>
  <xsd:complexType mixed="true">
   <xsd:sequence minOccurs="0" maxOccurs="unbounded">
    <xsd:any processContents="lax"/>
   </xsd:sequence>
   <xsd:attributeGroup ref="title"/>
   <xsd:attributeGroup ref="id"/>
   <xsd:attributeGroup ref="convention"/>
   <xsd:attributeGroup ref="dictRef"/>
   <xsd:attributeGroup ref="type"/>
   <xsd:attributeGroup ref="count"/>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="operator" id="el.operator" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">An operator within an expression.</h:div>
    <h:div class="description">Experimental. An operator acts on one or more arguments (at present the number is fixed by the type). The formulation is reverse Polish so the result (with its dataType) is put on a stack for further use.</h:div>
    <h:div class="example" href="potential1.xml"/>
   </xsd:documentation>
  </xsd:annotation>
  <xsd:complexType>
   <xsd:sequence>
    <xsd:choice minOccurs="0" maxOccurs="unbounded"/>
   </xsd:sequence>
   <xsd:attributeGroup ref="title"/>
   <xsd:attributeGroup ref="id"/>
   <xsd:attributeGroup ref="convention"/>
   <xsd:attributeGroup ref="dictRef"/>
   <xsd:attributeGroup ref="type"/>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="parameter" id="el.parameter" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">A parameter describing the computation.</h:div>
    <h:div class="description">
     <h:p>A parameter is a broad concept and can describe numeric quantities, objects, keywords, etc. The distinction between keywords and parameters is often fuzzy. ("MINIM" might mean "minimize", while "MINIM=3" might require three iterations to be run. It may help to think of control keywords as boolean parameters. </h:p>
     <h:p>Numeric parameters can describe values in molecules, forcefields or other objects. Often the parameters will be refined or otherwise varied during the calculation. Some parameters may be fixed at particular values or relaxed at different stages in the calculation. Parameters can have errors, gradients and other indications of uncertainty.</h:p>
     <h:p>String/character parameters are often abbreviated in program input, and this is supported through the 
      <h:tt>regex</h:tt> and 
      <h:tt>ignoreCase</h:tt> attributes. ?????
     </h:p>
     <h:p>Parameters will usually be defined separately from the objects and use the 
      <h:tt>ref</h:tt> attribute to reference them.
     </h:p>
     <h:p>Parameters can be used to describe additional constraints. This will probably require the development of a microlanguage and until then may use program-specific mechanisms. A common approach will be to use an array of values (or objects) to represent different input values for (parts of) the calculation. Thus a conformational change could be specified by an array of several torsion angles.</h:p>
     <h:p>A parameter will frequently have a 
      <h:tt>dictRef</h:tt> pointing to a dictionary which may have more information about how the parameter is to be used or the values it can take. 
     </h:p>
     <h:p>The allowable content of 
      <h:tt>parameter</h:tt>s may be shown by a "template" in the 
      <h:tt>appinfo</h:tt>; this is stil experimental.
     </h:p>
    </h:div>
    <h:div class="example" href="parameter1.xml"/>
   </xsd:documentation>
  </xsd:annotation>
  <xsd:complexType>
   <xsd:sequence>
    <xsd:choice minOccurs="0" maxOccurs="unbounded">
     <xsd:element ref="scalar"/>
     <xsd:element ref="array"/>
     <xsd:element ref="matrix"/>
     <xsd:element ref="property"/>
     <xsd:element ref="expression"/>
    </xsd:choice>
    <xsd:choice minOccurs="0" maxOccurs="1">
     <xsd:element ref="gradient"/>
    </xsd:choice>
   </xsd:sequence>
   <xsd:attributeGroup ref="ref"/>
   <xsd:attributeGroup ref="title"/>
   <xsd:attributeGroup ref="id"/>
   <xsd:attributeGroup ref="convention"/>
   <xsd:attributeGroup ref="dictRef"/>
   <xsd:attributeGroup ref="value">
    <xsd:annotation>
     <xsd:documentation>
      <h:div class="specific">This is a shorthand for a single scalar value of the parameter. It should only be used with the 
       <h:tt>ref</h:tt> attribute as it inherits all the dataTyping of the referenced element. It must not be used for defining new parameters as it has no mechanism for units and dataTyping. [This may change?].
      </h:div>
     </xsd:documentation>
    </xsd:annotation>
   </xsd:attributeGroup>
   <xsd:attributeGroup ref="constraint"/>
   <xsd:attributeGroup ref="name"/>
   <xsd:attributeGroup ref="role">
    <xsd:annotation>
     <xsd:documentation>
      <h:div class="specific">
       <h:p>Used to define concepts such as independent and dependent variables</h:p>
      </h:div>
     </xsd:documentation>
    </xsd:annotation>
   </xsd:attributeGroup>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="parameterList" id="el.parameterList" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">A container for one or more parameters.</h:div>
    <h:div class="description">parameterList can contain several parameters.</h:div>
    <h:div class="example" href="parameterList1.xml"/>
    <h:div class="curation">2006-02-16:PMR. Added parameterList as child</h:div>
   </xsd:documentation>
  </xsd:annotation>
  <xsd:complexType>
   <xsd:sequence>
    <xsd:element ref="metadataList" minOccurs="0" maxOccurs="unbounded"/>
    <xsd:element ref="name" minOccurs="0" maxOccurs="unbounded"/>
    <xsd:choice minOccurs="0" maxOccurs="unbounded">
     <xsd:element ref="parameter"/>
     <xsd:element ref="parameterList"/>
     <!-- I don't know how to include this... <xsd:any processContents="lax"/> -->
    </xsd:choice>
   </xsd:sequence>
   <xsd:attributeGroup ref="dictRef"/>
   <xsd:attributeGroup ref="convention"/>
   <xsd:attributeGroup ref="title"/>
   <xsd:attributeGroup ref="id"/>
   <xsd:attributeGroup ref="ref"/>
   <xsd:attributeGroup ref="role"/>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="particle" id="el.particle" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">An object in space carrying a set of properties.</h:div>
    <h:div class="description">
     <h:tt>particles</h:tt> have many of the characteristics of 
     <h:tt>atom</h:tt>s but without an atomic nucleus. It does not have an elementType and cannot be involved in bonding, etc. It has coordinates, may carry charge and might have a mass. It represents some aspect of a computational model and should not be used for purely geometrical concepts such as centroid. Examples of particles are "shells" (e.g. in GULP) which are linked to atoms for modelling polarizability or lonepairs and approximations to multipoles. Properties such as charge, mass should be scalar/array/matrix children.
    </h:div>
    <!-- <h:div class="example" href="particle1.xml"></h:div> -->
   </xsd:documentation>
  </xsd:annotation>
  <xsd:complexType>
   <xsd:sequence>
    <xsd:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
   </xsd:sequence>
   <xsd:attributeGroup ref="title"/>
   <xsd:attributeGroup ref="id"/>
   <xsd:attributeGroup ref="convention"/>
   <xsd:attributeGroup ref="dictRef"/>
   <xsd:attributeGroup ref="type">
    <xsd:annotation>
     <xsd:documentation>
      <h:div class="specific">Used in a similar manner to 
       <h:tt>atomType</h:tt>. Examples might be "lonePair", "polarizable Oxygen", etc.
      </h:div>
     </xsd:documentation>
    </xsd:annotation>
   </xsd:attributeGroup>
   <xsd:attributeGroup ref="x3"/>
   <xsd:attributeGroup ref="y3"/>
   <xsd:attributeGroup ref="z3"/>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="peak" id="el.peak" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">A peak; annotated by human or machine.</h:div>
    <h:div class="description">
     <h:p>A 
      <h:tt>peak</h:tt> can describe: 
      <h:ul>
       <h:li>A single point in a spectrum. Usually a maximum but could be a shoulder, inflexion or indeed any point of interest.</h:li>
       <h:li>A continuous range of values within a spectrum, defined by maximum and minimum values on either/both axes</h:li>
      </h:ul>
     </h:p> The finer structure of the peak can be given with one or more peakStructure children
    </h:div>
    <h:div class="description">The units should always be given. (The raw spectral data may unfortunately use different units and no assumptions should be made).</h:div>
    <h:div class="description">The content model includes atom, bond, molecule, but these are deprecated and should be replaced by atomRefs, etc.</h:div>
    <h:div class="curation">2005-11-22: PMR. Added moleculeRefs</h:div>
    <h:div class="example" href="peak1.xml"/>
   </xsd:documentation>
  </xsd:annotation>
  <xsd:complexType>
   <xsd:sequence>
    <xsd:element ref="metadataList" minOccurs="0">
     <xsd:annotation>
      <xsd:documentation>
       <h:div class="summary">Allows 
        <h:i>inter alia</h:i> the provenance of the peak assignment to be recorde.
       </h:div>
      </xsd:documentation>
     </xsd:annotation>
    </xsd:element>
    <xsd:choice minOccurs="0" maxOccurs="unbounded">
     <xsd:element ref="atom">
      <xsd:annotation>
       <xsd:documentation>
        <h:div class="curation">2005-11-9. DEPRECATED; use atomRefs</h:div>
       </xsd:documentation>
      </xsd:annotation>
     </xsd:element>
     <xsd:element ref="bond">
      <xsd:annotation>
       <xsd:documentation>
        <h:div class="curation">2005-11-9. DEPRECATED; use bondRefs</h:div>
       </xsd:documentation>
      </xsd:annotation>
     </xsd:element>
     <xsd:element ref="molecule">
      <xsd:annotation>
       <xsd:documentation>
        <h:div class="curation">2005-11-9. DEPRECATED; use moleculeRefs when developed</h:div>
       </xsd:documentation>
      </xsd:annotation>
     </xsd:element>
     <xsd:element ref="peakStructure">
      <xsd:annotation>
       <xsd:documentation>
        <h:div class="curation">2005-11-9. PMR, added</h:div>
       </xsd:documentation>
      </xsd:annotation>
     </xsd:element>
    </xsd:choice>
   </xsd:sequence>
   <xsd:attributeGroup ref="dictRef"/>
   <xsd:attributeGroup ref="convention"/>
   <xsd:attributeGroup ref="title"/>
   <xsd:attributeGroup ref="id"/>
   <xsd:attributeGroup ref="ref"/>
   <xsd:attributeGroup ref="peakHeight"/>
   <xsd:attributeGroup ref="peakMultiplicity"/>
   <xsd:attributeGroup ref="peakShape"/>
   <xsd:attributeGroup ref="integral"/>
   <xsd:attributeGroup ref="peakUnits"/>
   <xsd:attributeGroup ref="xMin"/>
   <xsd:attributeGroup ref="xMax"/>
   <xsd:attributeGroup ref="xValue"/>
   <xsd:attributeGroup ref="xWidth"/>
   <xsd:attributeGroup ref="xUnits"/>
   <xsd:attributeGroup ref="yMin"/>
   <xsd:attributeGroup ref="yMax"/>
   <xsd:attributeGroup ref="yValue"/>
   <xsd:attributeGroup ref="yWidth"/>
   <xsd:attributeGroup ref="yUnits"/>
   <xsd:attributeGroup ref="atomRefs">
    <xsd:annotation>
     <xsd:documentation>
      <h:div class="summary">Atoms contributing to this peak</h:div>
      <h:div class="description">The primary set of atoms responsible for the peak such as an NMR peak. Coupling constants and similar splitting should not use this but peakStructure. At present there is no substructure to this attribute or concept and only one attribute is allowed. It may be combined with bondRefs. Even single atoms should use atomRefs, not atomRef. </h:div>
     </xsd:documentation>
    </xsd:annotation>
   </xsd:attributeGroup>
   <xsd:attributeGroup ref="bondRefs">
    <xsd:annotation>
     <xsd:documentation>
      <h:div class="summary">Bonds contributing to this peak</h:div>
      <h:div class="description">The primary set of bonds responsible for the peak such as an IR frequency. At present there is no substructure to this attribute or concept and only one attribute is allowed. It may be combined with atomRefs.</h:div>
     </xsd:documentation>
    </xsd:annotation>
   </xsd:attributeGroup>
   <xsd:attributeGroup ref="moleculeRefs">
    <xsd:annotation>
     <xsd:documentation>
      <h:div class="summary">Molecule(s) contributing to this peak</h:div>
      <h:div class="description">The molecule or molecule responsible for the peak. At present there is no substructure to this attribute or concept and only one attribute is allowed. This might, for example, be used to manage a mass spectrum or chromatogram</h:div>
     </xsd:documentation>
    </xsd:annotation>
   </xsd:attributeGroup>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="peakGroup" id="el.peakGroup" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">A list of closely related peaks or peakGroups.</h:div>
    <h:div class="description">Distinguish between 
     <h:tt>peakList</h:tt> (primarily a navigational container) and 
     <h:tt>peakGroup</h:tt> where the peaks (or groups) have some close relation not shared by all peaks. All descendants must use consistent units.
    </h:div>
    <h:div class="curation">2005-11-22. added atomRefs, bondRefs and moleculeRefs and deprecated atom, bond, molecule children</h:div>
    <h:div class="example" href="peakGroup1.xml"/>
   </xsd:documentation>
  </xsd:annotation>
  <xsd:complexType>
   <xsd:sequence>
    <xsd:element ref="metadataList" minOccurs="0">
     <xsd:annotation>
      <xsd:documentation>
       <h:div class="summary">Allows 
        <h:i>inter alia</h:i> the provenance of the peak assignment to be recorde.
       </h:div>
      </xsd:documentation>
     </xsd:annotation>
    </xsd:element>
    <xsd:choice minOccurs="0" maxOccurs="unbounded">
     <xsd:element ref="peak"/>
     <xsd:element ref="peakGroup"/>
     <xsd:element ref="atom">
      <xsd:annotation>
       <xsd:documentation>
        <h:div class="curation">2005-11-22. DEPRECATED; use atomRefs</h:div>
       </xsd:documentation>
      </xsd:annotation>
     </xsd:element>
     <xsd:element ref="bond">
      <xsd:annotation>
       <xsd:documentation>
        <h:div class="curation">2005-11-22. DEPRECATED; use bondRefs</h:div>
       </xsd:documentation>
      </xsd:annotation>
     </xsd:element>
     <xsd:element ref="molecule">
      <xsd:annotation>
       <xsd:documentation>
        <h:div class="curation">2005-11-22. DEPRECATED; use moleculeRefs</h:div>
       </xsd:documentation>
      </xsd:annotation>
     </xsd:element>
    </xsd:choice>
   </xsd:sequence>
   <xsd:attributeGroup ref="dictRef"/>
   <xsd:attributeGroup ref="convention"/>
   <xsd:attributeGroup ref="title"/>
   <xsd:attributeGroup ref="id"/>
   <xsd:attributeGroup ref="ref"/>
   <xsd:attributeGroup ref="peakHeight"/>
   <xsd:attributeGroup ref="peakMultiplicity"/>
   <xsd:attributeGroup ref="peakShape"/>
   <xsd:attributeGroup ref="integral"/>
   <xsd:attributeGroup ref="peakUnits"/>
   <xsd:attributeGroup ref="xMin"/>
   <xsd:attributeGroup ref="xMax"/>
   <xsd:attributeGroup ref="xValue"/>
   <xsd:attributeGroup ref="xWidth"/>
   <xsd:attributeGroup ref="xUnits"/>
   <xsd:attributeGroup ref="yMin"/>
   <xsd:attributeGroup ref="yMax"/>
   <xsd:attributeGroup ref="yValue"/>
   <xsd:attributeGroup ref="yWidth"/>
   <xsd:attributeGroup ref="yUnits"/>
   <xsd:attributeGroup ref="atomRefs">
    <xsd:annotation>
     <xsd:documentation>
      <h:div class="summary">Atoms contributing to this peak</h:div>
      <h:div class="description">The primary set of atoms responsible for the peak such as an NMR peak. Coupling constants and similar splitting should not use this but peakStructure. At present there is no substructure to this attribute or concept and only one attribute is allowed. It may be combined with bondRefs. Even single atoms should use atomRefs, not atomRef. </h:div>
     </xsd:documentation>
    </xsd:annotation>
   </xsd:attributeGroup>
   <xsd:attributeGroup ref="bondRefs">
    <xsd:annotation>
     <xsd:documentation>
      <h:div class="summary">Bonds contributing to this peak</h:div>
      <h:div class="description">The primary set of bonds responsible for the peak such as an IR frequency. At present there is no substructure to this attribute or concept and only one attribute is allowed. It may be combined with atomRefs.</h:div>
     </xsd:documentation>
    </xsd:annotation>
   </xsd:attributeGroup>
   <xsd:attributeGroup ref="moleculeRefs">
    <xsd:annotation>
     <xsd:documentation>
      <h:div class="summary">Molecule(s) contributing to this peak</h:div>
      <h:div class="description">The molecule or molecule responsible for the peak. At present there is no substructure to this attribute or concept and only one attribute is allowed. This might, for example, be used to manage a mass spectrum or chromatogram</h:div>
     </xsd:documentation>
    </xsd:annotation>
   </xsd:attributeGroup>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="peakList" id="el.peakList" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">A list of peaks or peakGroups.</h:div>
    <h:div class="description">Distinguish between 
     <h:tt>peakList</h:tt> (primarily a navigational container) and 
     <h:tt>peakGroup</h:tt> where the peaks (or groups) have some close relation not shared by all peaks. All peaks and peakGroups should use the same units.
    </h:div>
    <h:div class="example" href="peakList1.xml"/>
   </xsd:documentation>
  </xsd:annotation>
  <xsd:complexType>
   <xsd:sequence>
    <xsd:element ref="metadataList" minOccurs="0">
     <xsd:annotation>
      <xsd:documentation>
       <h:div class="summary">Allows 
        <h:i>inter alia</h:i> the provenance of the peak assignment to be recorde.
       </h:div>
      </xsd:documentation>
     </xsd:annotation>
    </xsd:element>
    <xsd:choice minOccurs="0" maxOccurs="unbounded">
     <xsd:element ref="peak"/>
     <xsd:element ref="peakGroup"/>
    </xsd:choice>
   </xsd:sequence>
   <xsd:attributeGroup ref="dictRef"/>
   <xsd:attributeGroup ref="convention"/>
   <xsd:attributeGroup ref="title"/>
   <xsd:attributeGroup ref="id"/>
   <xsd:attributeGroup ref="ref"/>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="peakStructure" id="el.peakStructure" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">The structure of a peak.</h:div>
    <h:div class="description">Primarily to record couplings and other fine structure. At present we have tested this on HNMR spectra, C13 NMR and simple IR. We believe that other types of spectroscopy (ESR, NQR, etc) can be represented to some extent, but there may be systems beyond the current expressive power.</h:div>
    <h:div>For molecules without symmetry we believe that most of the important types of NMR coupling can be represented. Thus an atom which gives rise to two couplings can have two child PeakStructures, and this is shown in example1. 
     <h:pre> &lt;cml xmlns="http://www.xml-cml.org/schema"&gt; &lt;!-- Ha ... Hb ... Hc1, Hc2 --&gt; &lt;molecule id="m1"&gt; &lt;atomArray&gt; &lt;atom id="a1" elementType="H"&gt; &lt;label value="Ha"/&gt; &lt;/atom&gt; &lt;atom id="a2" elementType="H"&gt; &lt;label value="Hb"/&gt; &lt;/atom&gt; &lt;atom id="a3" elementType="H"&gt; &lt;label value="Hc1"/&gt; &lt;/atom&gt; &lt;atom id="a4" elementType="H"&gt; &lt;label value="Hc2"/&gt; &lt;/atom&gt; &lt;/atomArray&gt; &lt;/molecule&gt; &lt;spectrum id="spectrum2" title="test peaks"&gt; &lt;peakList&gt; &lt;peak id="p1" title="Ha" atomRefs="a1" peakShape="sharp" xUnits="unit:ppm" xValue="6.0"&gt; &lt;peakStructure type="coupling" peakMultiplicity="doublet11" value="12" units="unit:hertz" atomRefs="a2"/&gt; &lt;/peak&gt; &lt;peak id="p2" title="Hb" atomRefs="a2" peakShape="sharp" xUnits="unit:ppm" xValue="7.0"&gt; &lt;peakStructure type="coupling" peakMultiplicity="doublet11" value="12" units="unit:hertz" atomRefs="a1"/&gt; &lt;peakStructure type="coupling" peakMultiplicity="triplet121" value="15" units="unit:hertz" atomRefs="a3 a4"/&gt; &lt;/peak&gt; &lt;peak id="p3" title="Hc" atomRefs="a3 a4" peakShape="sharp" xUnits="unit:ppm" xValue="8.0"&gt; &lt;peakStructure type="coupling" peakMultiplicity="doublet11" value="15" units="unit:hertz" atomRefs="a2"/&gt; &lt;/peak&gt; &lt;/peakList&gt; &lt;/spectrum&gt; &lt;/cml&gt; </h:pre> Where a peak is due to symmetry-related atoms there are different couplings to symmetrical atoms. Thus in an AA'BB' system there can be two couplings to the A atoms and we need nested peakStructures to represent these. In this case the order of the atoms in the peak@atomRefs maps to the order of the grandchildren. See example2. 
     <h:pre> &lt;!-- AA'BB' where there are 2 Ha and 2 Hb with two couplings J1 Ha ... Hb and Ha' ... Hb' J2 Ha ... Hb' and Ha' ... Hb --&gt; &lt;molecule id="m1"&gt; &lt;atomArray&gt; &lt;atom id="a1" elementType="H"&gt; &lt;label value="Ha"/&gt; &lt;/atom&gt; &lt;atom id="a2" elementType="H"&gt; &lt;label value="Ha'"/&gt; &lt;/atom&gt; &lt;atom id="a3" elementType="H"&gt; &lt;label value="Hb"/&gt; &lt;/atom&gt; &lt;atom id="a4" elementType="H"&gt; &lt;label value="Hb'"/&gt; &lt;/atom&gt; &lt;/atomArray&gt; &lt;/molecule&gt; &lt;spectrum id="spectrum2" title="test peaks"&gt; &lt;peakList&gt; &lt;!-- the ORDER of a1 and a2 is linked to the ORDER of the grandchildren elements, i.e. a1 couples to atoms in ps11 and ps21 while a2 relates to atoms is ps21 and ps22 --&gt; &lt;peak id="p1" title="Ha" atomRefs="a1, a2" peakShape="sharp" xUnits="unit:ppm" xValue="6.0"&gt; &lt;peakStructure id="ps1" type="coupling" peakMultiplicity="doublet" value="10" units="unit:hertz"&gt; &lt;peakStructure id="ps11" atomRefs="a3"/&gt; &lt;peakStructure id="ps12" atomRefs="a4"/&gt; &lt;/peakStructure&gt; &lt;peakStructure id="ps2" type="coupling" peakMultiplicity="doublet" value="2" units="unit:hertz"&gt; &lt;peakStructure id="ps21" atomRefs="a4"/&gt; &lt;peakStructure id="ps22" atomRefs="a3"/&gt; &lt;/peakStructure&gt; &lt;/peak&gt; &lt;/peakList&gt; &lt;/spectrum&gt; &lt;/cml&gt; </h:pre>
    </h:div>
    <h:div class="example" href="peakStructure1.xml"/>
    <h:div class="example" href="peakStructure2.xml"/>
   </xsd:documentation>
  </xsd:annotation>
  <xsd:complexType>
   <xsd:sequence>
    <xsd:element ref="metadataList" minOccurs="0" maxOccurs="unbounded">
     <xsd:annotation>
      <xsd:documentation>
       <h:div class="summary">Allows 
        <h:i>inter alia</h:i> the provenance of the peakStructure assignment to be recorded.
       </h:div>
      </xsd:documentation>
     </xsd:annotation>
    </xsd:element>
    <xsd:element ref="peakStructure" minOccurs="0" maxOccurs="unbounded">
     <xsd:annotation>
      <xsd:documentation>
       <h:div class="summary">Allows identification of couplings in symmetric systems. May also be usable for other complicated systems.</h:div>
      </xsd:documentation>
     </xsd:annotation>
    </xsd:element>
   </xsd:sequence>
   <xsd:attributeGroup ref="dictRef"/>
   <xsd:attributeGroup ref="convention"/>
   <xsd:attributeGroup ref="title"/>
   <xsd:attributeGroup ref="id"/>
   <xsd:attributeGroup ref="ref"/>
   <xsd:attributeGroup ref="peakMultiplicity"/>
   <xsd:attributeGroup ref="peakStructureType"/>
   <xsd:attributeGroup ref="peakShape"/>
   <xsd:attributeGroup ref="value"/>
   <xsd:attributeGroup ref="units"/>
   <xsd:attributeGroup ref="atomRefs">
    <xsd:annotation>
     <xsd:documentation>
      <h:div class="summary">The atoms to which the peakStructure refers.</h:div>
      <h:div class="description">Allows identification of the atoms to which the peak is coupled (not the atoms contributing to the primnary reference for which 
       <tt xmlns="">peak</tt> should be used). It may be combined with bondRefs. Even single atoms should use atomRefs, not atomRef. 
      </h:div>
     </xsd:documentation>
    </xsd:annotation>
   </xsd:attributeGroup>
   <xsd:attributeGroup ref="bondRefs">
    <xsd:annotation>
     <xsd:documentation>
      <h:div class="summary">Bonds contributing to this peakStructure</h:div>
      <h:div class="description">Even a single bond should use bondRefs, not bondRef</h:div>
     </xsd:documentation>
    </xsd:annotation>
   </xsd:attributeGroup>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="plane3" id="el.plane3" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">A plane in 3-space.</h:div>
    <h:div class="description">An oriented plane of indefinite extent.</h:div>
   </xsd:documentation>
  </xsd:annotation>
  <xsd:complexType>
   <xsd:simpleContent>
    <xsd:extension base="plane3Type">
     <xsd:attributeGroup ref="convention"/>
     <xsd:attributeGroup ref="dictRef"/>
     <xsd:attributeGroup ref="id"/>
     <xsd:attributeGroup ref="title"/>
     <xsd:attributeGroup ref="units"/>
    </xsd:extension>
   </xsd:simpleContent>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="point3" id="el.point3" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">A point in 3-space.</h:div>
    <h:div class="description"/>
   </xsd:documentation>
  </xsd:annotation>
  <xsd:complexType>
   <xsd:simpleContent>
    <xsd:extension base="point3Type">
     <xsd:attributeGroup ref="convention"/>
     <xsd:attributeGroup ref="dictRef"/>
     <xsd:attributeGroup ref="id"/>
     <xsd:attributeGroup ref="title"/>
     <xsd:attributeGroup ref="units"/>
    </xsd:extension>
   </xsd:simpleContent>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="potential" id="el.potential" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">An explicit potential.</h:div>
    <h:div class="description">This represents the actual function for the potential (i.e. with explicit values) rather than the functional form, which will normally be referenced from this.</h:div>
    <h:div class="example" href="potential1.xml"/>
   </xsd:documentation>
  </xsd:annotation>
  <xsd:complexType>
   <xsd:sequence>
    <xsd:choice minOccurs="0" maxOccurs="unbounded">
     <xsd:element ref="arg"/>
    </xsd:choice>
   </xsd:sequence>
   <xsd:attributeGroup ref="title"/>
   <xsd:attributeGroup ref="id"/>
   <xsd:attributeGroup ref="convention"/>
   <xsd:attributeGroup ref="dictRef"/>
   <xsd:attributeGroup ref="form"/>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="potentialForm" id="el.potentialForm" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">The functional form of a potential.</h:div>
    <h:div class="description">This has generic arguments and parameters rather than explicit ones. It is essentially a mathematical function, expressed currently in reverse Polish notation.</h:div>
    <h:div class="example" href="potential1.xml"/>
   </xsd:documentation>
  </xsd:annotation>
  <xsd:complexType>
   <xsd:sequence>
    <!-- <xsd:choice minOccurs="0" maxOccurs="unbounded"> <xsd:element ref="annotation"/> </xsd:choice> -->
    <xsd:choice minOccurs="0" maxOccurs="unbounded">
     <xsd:element ref="arg"/>
    </xsd:choice>
    <xsd:choice minOccurs="0" maxOccurs="unbounded">
     <xsd:element ref="parameter"/>
    </xsd:choice>
    <xsd:choice minOccurs="0" maxOccurs="1">
     <xsd:element ref="expression"/>
    </xsd:choice>
   </xsd:sequence>
   <xsd:attributeGroup ref="title"/>
   <xsd:attributeGroup ref="id"/>
   <xsd:attributeGroup ref="convention"/>
   <xsd:attributeGroup ref="dictRef"/>
   <xsd:attributeGroup ref="name"/>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="potentialList" id="el.potentialList" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">A container for explicit potentials.</h:div>
    <h:div class="description">Experimental.</h:div>
    <h:div class="example" href="potential1.xml"/>
   </xsd:documentation>
  </xsd:annotation>
  <xsd:complexType>
   <xsd:sequence>
    <xsd:choice minOccurs="0" maxOccurs="unbounded">
     <xsd:element ref="potential"/>
    </xsd:choice>
   </xsd:sequence>
   <xsd:attributeGroup ref="title"/>
   <xsd:attributeGroup ref="id"/>
   <xsd:attributeGroup ref="convention"/>
   <xsd:attributeGroup ref="dictRef"/>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="product" id="el.product" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">A product within a productList.</h:div>
    <h:div class="description">
     <h:tt>product</h:tt> describes a product species which is produced in a reaction. See 
     <h:tt>reactant</h:tt> for discussion of catalysis and solvents.
    </h:div>
    <h:div class="example" href="product1.xml"/>
   </xsd:documentation>
  </xsd:annotation>
  <xsd:complexType>
   <xsd:annotation>
    <xsd:documentation>
     <h:div class="description">
      <h:p>A product will normally be identified by name(s), formula, or molecule and at least one of these should normally be given. Amount(s) of product can be given after this identification and can describe mass, volume, percent yield, etc. but not stoichiometry</h:p>
     </h:div>
    </xsd:documentation>
   </xsd:annotation>
   <xsd:sequence>
    <xsd:element ref="metadataList" minOccurs="0" maxOccurs="unbounded"/>
    <xsd:choice minOccurs="0" maxOccurs="unbounded">
     <xsd:element ref="identifier" minOccurs="0"/>
     <xsd:element ref="label" minOccurs="0"/>
     <xsd:element ref="name" minOccurs="0"/>
    </xsd:choice>
    <xsd:element ref="molecule" minOccurs="0" maxOccurs="1"/>
    <xsd:element ref="electron" minOccurs="0" maxOccurs="1"/>
    <xsd:element ref="substance" minOccurs="0" maxOccurs="1"/>
    <xsd:element ref="substanceList" minOccurs="0" maxOccurs="1"/>
    <xsd:element ref="formula" minOccurs="0" maxOccurs="1"/>
    <xsd:element ref="amount" minOccurs="0" maxOccurs="unbounded"/>
   </xsd:sequence>
   <xsd:attributeGroup ref="dictRef"/>
   <xsd:attributeGroup ref="convention"/>
   <xsd:attributeGroup ref="title"/>
   <xsd:attributeGroup ref="id"/>
   <xsd:attributeGroup ref="ref"/>
   <xsd:attributeGroup ref="role"/>
   <xsd:attributeGroup ref="count"/>
   <xsd:attributeGroup ref="state"/>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="productList" id="el.productList" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">A container for one or more products.</h:div>
    <h:div class="description">
     <h:p>
      <h:tt>productList</h:tt> can contain several products. These may be related in several ways, including 
      <h:ul>
       <h:li>single list of products</h:li>
       <h:li>grouping of products of parallel reactions</h:li>
      </h:ul>. A productList can contain nested productLists. The semantics of this are currently undefined. 
     </h:p>
    </h:div>
    <h:div class="example" href="productList1.xml"/>
   </xsd:documentation>
  </xsd:annotation>
  <xsd:complexType>
   <xsd:sequence>
    <xsd:element ref="metadataList" minOccurs="0" maxOccurs="unbounded"/>
    <xsd:element ref="name" minOccurs="0" maxOccurs="unbounded"/>
    <xsd:choice minOccurs="0" maxOccurs="unbounded">
     <xsd:element ref="productList"/>
     <xsd:element ref="product"/>
    </xsd:choice>
   </xsd:sequence>
   <xsd:attributeGroup ref="dictRef"/>
   <xsd:attributeGroup ref="convention"/>
   <xsd:attributeGroup ref="title"/>
   <xsd:attributeGroup ref="id"/>
   <xsd:attributeGroup ref="ref"/>
   <xsd:attributeGroup ref="role"/>
   <xsd:attributeGroup ref="count">
    <xsd:annotation>
     <xsd:documentation>
      <h:div class="specific">The number of copies of the productList involved in the stoichiometric reaction. Probably not useful for simple reactions but could be used for parallel reactions.</h:div>
     </xsd:documentation>
    </xsd:annotation>
   </xsd:attributeGroup>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="property" id="el.property" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">A container for a property.</h:div>
    <h:div class="description">
     <h:tt>property</h:tt> can contain one or more children, usually 
     <h:tt>scalar</h:tt>, 
     <h:tt>array</h:tt> or 
     <h:tt>matrix</h:tt>. The 
     <h:tt>dictRef</h:tt> attribute is required, even if there is a single scalar child with the same dictRef. The property may have a different dictRef from the child, thus providing an extension mechanism. 
     <h:p>Properties may have a 
      <h:tt>state</h:tt> attribute to distinguish the state of matter
     </h:p>
    </h:div>
    <h:div class="example" href="property1.xml"/>
   </xsd:documentation>
  </xsd:annotation>
  <xsd:complexType>
   <xsd:sequence>
    <xsd:element ref="metadataList" minOccurs="0" maxOccurs="unbounded"/>
    <xsd:element ref="name" minOccurs="0" maxOccurs="unbounded"/>
    <xsd:choice minOccurs="0" maxOccurs="unbounded">
     <xsd:element ref="scalar"/>
     <xsd:element ref="array"/>
     <xsd:element ref="matrix"/>
    </xsd:choice>
   </xsd:sequence>
   <xsd:attributeGroup ref="dictRef"/>
   <xsd:attributeGroup ref="convention"/>
   <xsd:attributeGroup ref="title"/>
   <xsd:attributeGroup ref="id"/>
   <xsd:attributeGroup ref="ref"/>
   <xsd:attributeGroup ref="role">
    <xsd:annotation>
     <xsd:documentation>
      <h:div class="specific">Semantics are not yet controlled but could include thermochemistry, kinetics or other common properties.</h:div>
     </xsd:documentation>
    </xsd:annotation>
   </xsd:attributeGroup>
   <xsd:attributeGroup ref="state"/>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="propertyList" id="el.propertyList" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">A container for one or more properties.</h:div>
    <h:div class="description">
     <h:tt>propertyList</h:tt> can contain several properties. These include (but are not limited to) observations, or numeric quantities.
    </h:div>
    <h:div class="example" href="propertyList1.xml"/>
   </xsd:documentation>
  </xsd:annotation>
  <xsd:complexType>
   <xsd:sequence>
    <xsd:element ref="metadataList" minOccurs="0" maxOccurs="unbounded"/>
    <xsd:element ref="name" minOccurs="0" maxOccurs="unbounded"/>
    <xsd:choice minOccurs="0" maxOccurs="unbounded">
     <xsd:element ref="property"/>
     <xsd:element ref="propertyList"/>
     <xsd:element ref="observation"/>
    </xsd:choice>
    <!-- <xsd:any processContents="lax" minOccurs="0" maxOccurs="unbounded"/>-->
   </xsd:sequence>
   <xsd:attributeGroup ref="dictRef"/>
   <xsd:attributeGroup ref="convention"/>
   <xsd:attributeGroup ref="title"/>
   <xsd:attributeGroup ref="id"/>
   <xsd:attributeGroup ref="ref"/>
   <xsd:attributeGroup ref="role"/>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="reactant" id="el.reactant" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">A reactant within a reactantList.</h:div>
    <h:div class="description">
     <h:tt>reactant</h:tt> describes a reactant species which takes part in a reaction. Catalysts and supports are not normally classified as reactants, but this is subjective. Enzymes (or parts of enzymes) may well be reactants, as could be substances which underwent chemical change but were restored to their original state. 
     <h:tt>reactant</h:tt> is a powerful concept as it can support stoichiometry (atom and molecule counting), mapping (for mechanisms), etc. Solvents are best contained within substanceList.
    </h:div>
    <h:div class="example" href="reactant1.xml"/>
   </xsd:documentation>
  </xsd:annotation>
  <xsd:complexType>
   <xsd:annotation>
    <xsd:documentation>
     <h:div>A reactant will normally be identified by name(s), formula, or molecule and at least one of these should normally be given. Amount(s) of reactant can be given after this identification and can describe mass, volume, etc. but not stoichiometr.</h:div>
    </xsd:documentation>
   </xsd:annotation>
   <xsd:sequence>
    <xsd:element ref="metadataList" minOccurs="0" maxOccurs="unbounded"/>
    <xsd:choice minOccurs="0" maxOccurs="unbounded">
     <xsd:element ref="identifier"/>
     <xsd:element ref="label"/>
     <xsd:element ref="name"/>
    </xsd:choice>
    <xsd:element ref="molecule" minOccurs="0" maxOccurs="1"/>
    <xsd:element ref="electron" minOccurs="0" maxOccurs="1"/>
    <xsd:element ref="substance" minOccurs="0" maxOccurs="1"/>
    <xsd:element ref="substanceList" minOccurs="0" maxOccurs="1"/>
    <xsd:element ref="formula" minOccurs="0" maxOccurs="1"/>
    <xsd:element ref="amount" minOccurs="0" maxOccurs="unbounded"/>
   </xsd:sequence>
   <xsd:attributeGroup ref="dictRef"/>
   <xsd:attributeGroup ref="convention"/>
   <xsd:attributeGroup ref="title"/>
   <xsd:attributeGroup ref="id"/>
   <xsd:attributeGroup ref="ref"/>
   <xsd:attributeGroup ref="role">
    <xsd:annotation>
     <xsd:documentation>
      <h:div class="specific">The role of the reactant within a reactantList. Semantics are not yet controlled but could be limiting, oxidant, etc. TODO: a reactant might have multiple roles so this may have to become an element.</h:div>
     </xsd:documentation>
    </xsd:annotation>
   </xsd:attributeGroup>
   <xsd:attributeGroup ref="count">
    <xsd:annotation>
     <xsd:documentation>
      <h:div class="specific">The number of copies of the reactant involved in the stoichiometric reaction. Could be non-integer but should not be used for actual ratios of materials added (for which amount should be used).</h:div>
     </xsd:documentation>
    </xsd:annotation>
   </xsd:attributeGroup>
   <xsd:attributeGroup ref="state"/>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="reactantList" id="el.reactantList" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">A container for one or more reactants.</h:div>
    <h:div class="description">
     <h:p>
      <h:tt>reactantList</h:tt> can contain several reactants. These may be related in several ways, including 
      <h:ul>
       <h:li>lists of related reactants</h:li>
       <h:li>reactant schemes</h:li>
       <h:li>multi-step reactants</h:li>
       <h:li>parallel and/or coupled reactants</h:li>
      </h:ul>. A reactantList can contain nested reactantLists. The semantics of this are currently undefined. 
     </h:p>
    </h:div>
    <h:div class="example" href="reactantList1.xml"/>
   </xsd:documentation>
  </xsd:annotation>
  <xsd:complexType>
   <xsd:sequence>
    <xsd:element ref="metadataList" minOccurs="0" maxOccurs="unbounded"/>
    <xsd:element ref="name" minOccurs="0" maxOccurs="1"/>
    <xsd:choice minOccurs="0" maxOccurs="unbounded">
     <xsd:element ref="reactantList"/>
     <xsd:element ref="reactant"/>
    </xsd:choice>
   </xsd:sequence>
   <xsd:attributeGroup ref="dictRef"/>
   <xsd:attributeGroup ref="convention"/>
   <xsd:attributeGroup ref="title"/>
   <xsd:attributeGroup ref="id"/>
   <xsd:attributeGroup ref="ref"/>
   <xsd:attributeGroup ref="role"/>
   <xsd:attributeGroup ref="count"/>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="reaction" id="el.reaction" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">A chemical reaction or reaction step.</h:div>
    <h:div class="description">
     <h:p>
      <h:tt>reaction</h:tt> is a container for reactants, products, conditions, properties and possibly other information relating to the reaction, often within a reactionList. Partial semantics exist: 
      <h:ul>
       <h:li>
        <h:b>name</h:b> the name(s) of the reaction
       </h:li>
       <h:li>
        <h:b>reactantList</h:b> (normally only one) the grouped reactants
       </h:li>
       <h:li>
        <h:b>spectatorList</h:b> substances with well-defined chemistry which are involved in the reaction but do not change. Examples are side groups in proteins, cofactors, etc. The division between specattor and substance is subjective.
       </h:li>
       <h:li>
        <h:b>substance</h:b> or 
        <h:b>substanceList</h:b> substances present in the reaction but not classified as reactants. Examples might be enzymes, catalysts, solvents, supports, workup, etc. 
       </h:li>
       <h:li>
        <h:b>condition</h:b> conditions of the reaction. These may be text strings, but ideally will have clearer semantics such as scalars for temperature, etc.
       </h:li>
       <h:li>
        <h:b>productList</h:b> the grouped products. This allows for parallel reactions or other semantics.
       </h:li>
       <h:li>
        <h:b>property</h:b> properties (often physical) associated with the reaction. Examples might be heat of formation, kinetics or equilibrium constant.
       </h:li>
      </h:ul>
     </h:p>
    </h:div>
    <h:div>
     <h:p>Reaction normally refers to an overall reaction or a step within a reactionList. For a complex "reaction", such as in enzymes or chain reactions, it may be best to use 
      <h:tt>reactionScheme</h:tt> to hold the overall 
      <h:tt>reaction</h:tt> and a 
      <h:tt>reactionList</h:tt> of the individual 
      <h:tt>reaction</h:tt> steps.
     </h:p>
    </h:div>
    <h:div class="example" href="reaction1.xml"/>
    <h:div class="example" href="reaction9a.xml"/>
    <h:div class="example" href="reaction9b.xml"/>
    <h:div class="example" href="reaction10a.xml"/>
    <h:div class="example" href="reaction10b.xml"/>
    <h:div class="example" href="reaction11.xml"/>
   </xsd:documentation>
  </xsd:annotation>
  <xsd:complexType>
   <xsd:annotation>
    <xsd:documentation>
     <h:div>
      <h:p>The semantics of the content model are</h:p>
      <h:ul>
       <h:li>metadataList for general metadata</h:li>
       <h:li>label for classifying or describing the reaction (e.g. "hydrolysis")</h:li>
       <h:li>identifier for unique identification. This could be a classification such as EC (enzyme commission) or an IChI-like string generated from the components.</h:li>
       <h:li>these are followed by the possible components of the reaction and/or a reactionList of further details.</h:li>
      </h:ul>.
     </h:div>
    </xsd:documentation>
   </xsd:annotation>
   <xsd:sequence>
    <xsd:element ref="metadataList" minOccurs="0" maxOccurs="unbounded"/>
    <xsd:element ref="label" minOccurs="0" maxOccurs="unbounded"/>
    <xsd:choice minOccurs="0" maxOccurs="unbounded">
     <xsd:element ref="name" minOccurs="0" maxOccurs="unbounded"/>
     <xsd:element ref="identifier" minOccurs="0" maxOccurs="unbounded"/>
    </xsd:choice>
    <xsd:sequence minOccurs="0" maxOccurs="unbounded">
     <xsd:element ref="reactiveCentre" minOccurs="0" maxOccurs="unbounded"/>
     <xsd:element ref="mechanism" minOccurs="0" maxOccurs="unbounded"/>
     <xsd:element ref="reactantList" minOccurs="0" maxOccurs="unbounded"/>
     <xsd:element ref="spectatorList" minOccurs="0" maxOccurs="unbounded"/>
     <xsd:element ref="substanceList" minOccurs="0" maxOccurs="unbounded"/>
     <xsd:element ref="conditionList" minOccurs="0" maxOccurs="unbounded"/>
     <xsd:element ref="transitionState" minOccurs="0" maxOccurs="unbounded"/>
     <xsd:element ref="productList" minOccurs="0" maxOccurs="unbounded"/>
     <xsd:element ref="propertyList" minOccurs="0" maxOccurs="unbounded"/>
     <xsd:element ref="map" minOccurs="0" maxOccurs="unbounded"/>
     <xsd:element ref="object" minOccurs="0" maxOccurs="unbounded">
      <xsd:annotation>
       <xsd:documentation>
        <h:div>This allows any objects to be attached to the reaction, but particularly graphical primitives such as lines, arrows, etc. These should be provided as elements where possible (e.g. SVG) and should have references to the chemical objects they interact with (i.e. not simply relying on geometry). Markers with IDs can be included as part of the graphics object and their ids linked to the chemical elements using 
         <h:tt>link</h:tt>.
        </h:div>
       </xsd:documentation>
      </xsd:annotation>
     </xsd:element>
    </xsd:sequence>
   </xsd:sequence>
   <xsd:attributeGroup ref="dictRef"/>
   <xsd:attributeGroup ref="convention"/>
   <xsd:attributeGroup ref="title"/>
   <xsd:attributeGroup ref="id"/>
   <xsd:attributeGroup ref="reactionFormat"/>
   <xsd:attributeGroup ref="ref"/>
   <xsd:attributeGroup ref="reactionRole"/>
   <xsd:attributeGroup ref="reactionType"/>
   <xsd:attributeGroup ref="state"/>
   <xsd:attributeGroup ref="atomMap"/>
   <xsd:attributeGroup ref="electronMap"/>
   <xsd:attributeGroup ref="bondMap"/>
   <xsd:attributeGroup ref="yield">
    <xsd:annotation>
     <xsd:documentation>
      <h:div class="specific">
       <h:p>The yield of the reaction. Note that this lies in the range 0-1.</h:p>
      </h:div>
     </xsd:documentation>
    </xsd:annotation>
   </xsd:attributeGroup>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="reactionList" id="el.reactionList" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">A container for one or more reactions or reactionSchemes with no interrelations.</h:div>
    <h:div class="description">A reactionList aggregates reactions and reactionSchemes but implies no semantics. The most common uses are to create small collections of reactions (e.g. databases or publications).</h:div>
    <h:div class="example" href="reactionList1.xml"/>
   </xsd:documentation>
  </xsd:annotation>
  <xsd:complexType>
   <xsd:annotation>
    <xsd:documentation>
     <h:div/>
    </xsd:documentation>
   </xsd:annotation>
   <xsd:sequence>
    <xsd:element ref="metadataList" minOccurs="0" maxOccurs="unbounded"/>
    <xsd:choice>
     <xsd:element ref="reactionScheme" minOccurs="0" maxOccurs="unbounded"/>
     <xsd:element ref="reaction" minOccurs="0" maxOccurs="unbounded"/>
    </xsd:choice>
   </xsd:sequence>
   <xsd:attributeGroup ref="dictRef"/>
   <xsd:attributeGroup ref="convention"/>
   <xsd:attributeGroup ref="title"/>
   <xsd:attributeGroup ref="id"/>
   <xsd:attributeGroup ref="name"/>
   <xsd:attributeGroup ref="ref"/>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="reactionScheme" id="el.reactionScheme" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">A container for two or more related reactions and their relationships.</h:div>
    <h:div class="description"> Where reactions are closely related (and often formally dependent on each other) they should be contained within the reactionStepList of a reactionScheme. The semantics which have informed this design include: 
     <h:ul>
      <h:li>Steps within an organic synthesis.</h:li>
      <h:li>Two or more individual (primitive) steps provding the detailed mechanism for an overall reaction.</h:li>
      <h:li>Coupled or sequential reactions within biochemical pathways.</h:li>
     </h:ul>
     <h:p>This design is general because "reaction" is used in several ways. A biochemical pathway (e.g. oxidation of glucose to CO2 and water) involves many coupled enzyme reactions proceeding both in parallel and in sequence. Each of these steps ("reactions" in their own right) is itself complex and can include several mechanistics steps which are themselves reactions with products, reactants, etc. 
      <h:tt>reactionScheme</h:tt> can therefore include reactionStepLists (with more reactionScheme children) which provide a more detailed view of the individual components.
     </h:p>
     <h:p>Where a set of reactions are primitives...</h:p>
    </h:div>
    <h:div class="example" href="reactionScheme1.xml"/>
    <h:div class="example" href="reactionScheme3.xml"/>
    <h:div class="example" href="reactionScheme4a.xml"/>
    <h:div class="example" href="reactionScheme4b.xml"/>
   </xsd:documentation>
  </xsd:annotation>
  <xsd:complexType>
   <xsd:annotation>
    <xsd:documentation>
     <h:div class="description">
      <h:p>The semantics of the content model are</h:p>
      <h:ul>
       <h:li>metadataList for general metadata</h:li>
       <h:li>label for classifying or describing the reaction (e.g. "hydrolysis")</h:li>
       <h:li>identifier for unique identification. This could be a classification such as EC (enzyme commission) or an IChI-like string generated from the components.</h:li>
       <h:li>these are followed by the possible components of the reaction and/or a reactionList of further details.</h:li>
      </h:ul>
     </h:div>
    </xsd:documentation>
   </xsd:annotation>
   <xsd:sequence>
    <xsd:element ref="metadataList" minOccurs="0" maxOccurs="unbounded"/>
    <xsd:choice minOccurs="0" maxOccurs="unbounded">
     <xsd:element ref="label"/>
     <xsd:element ref="name"/>
     <xsd:element ref="identifier"/>
    </xsd:choice>
    <xsd:choice minOccurs="0" maxOccurs="unbounded">
     <xsd:element ref="reaction"/>
     <xsd:element ref="reactionStepList"/>
     <xsd:element ref="reactionScheme"/>
    </xsd:choice>
   </xsd:sequence>
   <xsd:attributeGroup ref="dictRef"/>
   <xsd:attributeGroup ref="convention"/>
   <xsd:attributeGroup ref="title"/>
   <xsd:attributeGroup ref="id"/>
   <xsd:attributeGroup ref="ref"/>
   <xsd:attributeGroup ref="reactionRole"/>
   <xsd:attributeGroup ref="reactionType"/>
   <xsd:attributeGroup ref="state"/>
   <xsd:attributeGroup ref="reactionFormat"/>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="reactionStep" id="el.reactionStep" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">A child of reactionStepList and a container for reaction or reactionScheme.</h:div>
    <h:div class="description">
     <h:p>
      <h:tt>reactionStep</h:tt> is always contained within reactionStepList and is designed to manage "sub-reactions" which have close relationships. These will often involve reactions which, taken together, describe a higher level reaction or reaction type. Examples are: 
      <h:ul>
       <h:li>biochemical pathways</h:li>
       <h:li>synthetic reaction schemes</h:li>
       <h:li>multi-step reactions</h:li>
       <h:li>parallel and/or coupled reactions</h:li>
      </h:ul>. A reactionStep normally contains a single reaction or reactionScheme. It can have attributes such as yield and ratio which can be used by the parent reactionStepList. 
     </h:p>
    </h:div>
    <h:div class="example" href="reactionStepList4.xml"/>
    <h:div class="example" href="reactionStepList5a.xml"/>
    <h:div class="example" href="reactionStepList5b.xml"/>
   </xsd:documentation>
  </xsd:annotation>
  <xsd:complexType>
   <xsd:annotation>
    <xsd:documentation>
     <h:div>
      <h:p> The 
       <h:tt>name</h:tt> applies to the overall schema of reactions. 
       <h:tt>label</h:tt> is for additional textual information and classification. 
       <h:tt>reactionStepList</h:tt> normally contains 
       <h:tt>reaction</h:tt>s but we make provision for nested reactionSchemes if required. 
      </h:p>
     </h:div>
    </xsd:documentation>
   </xsd:annotation>
   <xsd:sequence>
    <xsd:element ref="metadataList" minOccurs="0" maxOccurs="unbounded"/>
    <xsd:choice minOccurs="0" maxOccurs="unbounded">
     <xsd:element ref="name"/>
     <xsd:element ref="label"/>
    </xsd:choice>
    <xsd:choice minOccurs="0" maxOccurs="unbounded">
     <xsd:element ref="reactionScheme"/>
     <xsd:element ref="reaction"/>
    </xsd:choice>
   </xsd:sequence>
   <xsd:attributeGroup ref="dictRef"/>
   <xsd:attributeGroup ref="convention"/>
   <xsd:attributeGroup ref="title"/>
   <xsd:attributeGroup ref="id"/>
   <xsd:attributeGroup ref="ref"/>
   <xsd:attributeGroup ref="yield">
    <xsd:annotation>
     <xsd:documentation>
      <h:div class="specific">
       <h:p>The yield of the reactionStep. Note that this lies in the range 0-1.</h:p>
      </h:div>
     </xsd:documentation>
    </xsd:annotation>
   </xsd:attributeGroup>
   <xsd:attributeGroup ref="ratio">
    <xsd:annotation>
     <xsd:documentation>
      <h:div class="specific">
       <h:p>The ratio of this step to one or more sibling steps. Note that this lies in the range 0-1. It is meaningless to use this unless there are siblings, in which case it refers to the relative molar fluxes through each. The "percentage yields" will need to be transformed to this range. There is no requirement that the sum of fluxes through a group of siblings sum to 1.0, though they should not sum to more.</h:p>
      </h:div>
     </xsd:documentation>
    </xsd:annotation>
   </xsd:attributeGroup>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="reactionStepList" id="el.reactionStepList" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">A container for one or more related reactionSteps.</h:div>
    <h:div class="description">
     <h:p>
      <h:tt>reactionStepList</h:tt> is always contained within reactionScheme and is designed to manage "sub-reactions" which have close relationships. These will often involve reactions which, taken together, describe a higher level reaction or reaction type. Examples are: 
      <h:ul>
       <h:li>biochemical pathways</h:li>
       <h:li>synthetic reaction schemes</h:li>
       <h:li>multi-step reactions</h:li>
       <h:li>parallel and/or coupled reactions</h:li>
      </h:ul>. A reactionStepList contains reactionSteps (each of which contains reactions and/or reactionSchemes (e.g. where part of the process is known in greater detail)). It may not directly contain child reactionStepLists. 
     </h:p>
     <h:p>The child reactionSteps can have attributes such as yield and ratio which describe the relationship of the component steps.</h:p>
     <h:p>Guidance on use: 
      <h:ul>
       <h:li>reactionScheme describes a complex of reactions with metadata, one (or more) overall reactions and a reactionStepList with the overall component reactions.</h:li>
       <h:li> reactionStepList aggregates and structures the individual subreactions. </h:li>
       <h:li>reactionList is a container for reactions and reactionSchemes with no semantics (e.g. a book or database of selected reactions). </h:li>
      </h:ul>
     </h:p>
    </h:div>
    <h:div class="example" href="reactionStepList1.xml"/>
    <h:div class="example" href="reactionStepList3.xml"/>
   </xsd:documentation>
  </xsd:annotation>
  <xsd:complexType>
   <xsd:annotation>
    <xsd:documentation>
     <h:div>
      <h:p> The 
       <h:tt>name</h:tt> applies to the overall schema of reactions. 
       <h:tt>label</h:tt> is for additional textual information and classification. 
       <h:tt>reactionStepList</h:tt> normally contains 
       <h:tt>reactionStep</h:tt>s. 
      </h:p>
     </h:div>
    </xsd:documentation>
   </xsd:annotation>
   <xsd:sequence>
    <xsd:element ref="metadataList" minOccurs="0" maxOccurs="unbounded"/>
    <xsd:choice minOccurs="0" maxOccurs="unbounded">
     <xsd:element ref="name"/>
     <xsd:element ref="label"/>
    </xsd:choice>
    <xsd:sequence minOccurs="0" maxOccurs="unbounded">
     <xsd:element ref="reactionStep"/>
    </xsd:sequence>
   </xsd:sequence>
   <xsd:attributeGroup ref="dictRef"/>
   <xsd:attributeGroup ref="convention"/>
   <xsd:attributeGroup ref="title"/>
   <xsd:attributeGroup ref="id"/>
   <xsd:attributeGroup ref="ref"/>
   <xsd:attributeGroup ref="type"/>
   <xsd:attributeGroup ref="reactionFormat"/>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="reactiveCentre" id="el.reactiveCentre" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">The reactiveCentre in a reaction.</h:div>
    <h:div class="description">This describes the set(s) of bonds and atoms involved in the reaction. The semantics are flexible, but a common usage would be to create atomSet(s) and bondSet(s) mapping to groups which undergo changes.</h:div>
    <h:div class="example" href="reactiveCentre1.xml"/>
   </xsd:documentation>
  </xsd:annotation>
  <xsd:complexType>
   <xsd:sequence>
    <xsd:element ref="description" minOccurs="0"/>
    <xsd:choice minOccurs="0" maxOccurs="unbounded">
     <xsd:element ref="atomTypeList"/>
     <xsd:element ref="bondTypeList"/>
     <xsd:element ref="atomSet"/>
     <xsd:element ref="bondSet"/>
    </xsd:choice>
   </xsd:sequence>
   <xsd:attributeGroup ref="title"/>
   <xsd:attributeGroup ref="id"/>
   <xsd:attributeGroup ref="convention"/>
   <xsd:attributeGroup ref="dictRef"/>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="region" id="el.region" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">A region of the system.</h:div>
    <h:div class="description">Under development. A subdivision of the system to which special protocols or properties may be attached. Typical regions could be defined by the presence of atoms belonging to an atomSet or geometrical boundaries.</h:div>
    <h:div class="note">A region element will not always contain other elements, but may have references from other elements. It may create a protocol, e.g. atoms within a region might be replaced by a continuum model or be subject to a field. Semantics yet to be determined.</h:div>
    <h:div>Regions can be created by the unions of two or more regions. This allows a region to be built from a series of (say) spheres or boxes filling space.</h:div>
    <h:div class="example" href="region1.xml"/>
   </xsd:documentation>
  </xsd:annotation>
  <xsd:complexType>
   <xsd:sequence/>
   <xsd:attributeGroup ref="sphere3"/>
   <xsd:attributeGroup ref="box3"/>
   <xsd:attributeGroup ref="atomSetRef"/>
   <xsd:attributeGroup ref="regionRefs"/>
   <xsd:attributeGroup ref="title"/>
   <xsd:attributeGroup ref="id"/>
   <xsd:attributeGroup ref="convention"/>
   <xsd:attributeGroup ref="dictRef"/>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="relatedEntry" id="el.relatedEntry" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">An entry related in some way to a dictionary entry.</h:div>
    <h:div class="description">The range of relationships is not restricted but should include parents, aggregation, seeAlso and so on. DataCategories from ISO12620 can be referenced through the namespaced mechanism.</h:div>
    <h:div class="example" href="relatedEntry1.xml"/>
   </xsd:documentation>
  </xsd:annotation>
  <xsd:complexType mixed="true">
   <xsd:attributeGroup ref="relatedEntryType"/>
   <xsd:attributeGroup ref="href">
    <xsd:annotation>
     <xsd:documentation>
      <h:div class="specific">The related entry.</h:div>
     </xsd:documentation>
    </xsd:annotation>
   </xsd:attributeGroup>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="sample" id="el.sample" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">An analytical or spectral sample.</h:div>
    <h:div class="description">The 
     <h:tt>sample</h:tt> should contain information on what things were in the sample and their roles. It can include 
     <h:tt>molecule</h:tt>, 
     <h:tt>substance</h:tt> and 
     <h:tt>substanceList</h:tt>. Typical rolos include solvent, mulling agents, salt disks, molecular supports, etc. but should not cover apparatus or conditions.
    </h:div>
    <h:div class="example" href="sample1.xml"/>
   </xsd:documentation>
  </xsd:annotation>
  <xsd:complexType>
   <xsd:sequence>
    <xsd:element ref="metadataList" minOccurs="0" maxOccurs="unbounded"/>
    <xsd:choice minOccurs="0" maxOccurs="unbounded">
     <xsd:element ref="molecule">
      <xsd:annotation>
       <xsd:documentation>
        <h:div>A molecular description.</h:div>
       </xsd:documentation>
      </xsd:annotation>
     </xsd:element>
     <xsd:element ref="substance">
      <xsd:annotation>
       <xsd:documentation>
        <h:div>A substance in the sample.</h:div>
       </xsd:documentation>
      </xsd:annotation>
     </xsd:element>
     <xsd:element ref="substanceList">
      <xsd:annotation>
       <xsd:documentation>
        <h:div>A list of substances in the sample.</h:div>
       </xsd:documentation>
      </xsd:annotation>
     </xsd:element>
    </xsd:choice>
   </xsd:sequence>
   <xsd:attributeGroup ref="dictRef"/>
   <xsd:attributeGroup ref="convention"/>
   <xsd:attributeGroup ref="title"/>
   <xsd:attributeGroup ref="id"/>
   <xsd:attributeGroup ref="ref"/>
   <xsd:attributeGroup ref="state"/>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="scalar" id="el.scalar" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">An element to hold scalar data.</h:div>
    <h:div class="description">
     <h:tt>scalar</h:tt> holds scalar data under a single generic container. The semantics are usually resolved by linking to a dictionary. 
     <h:b>scalar</h:b> defaults to a scalar string but has attributes which affect the type. 
     <h:p>
      <h:tt>scalar</h:tt> does not necessarily reflect a physical object (for which 
      <h:a href="el.object">object</h:a> should be used). It may reflect a property of an object such as temperature, size, etc. 
     </h:p>
     <h:p>Note that normal Schema validation tools cannot validate the data type of 
      <h:b>scalar</h:b> (it is defined as 
      <h:tt>string</h:tt>), but that a temporary schema can be constructed from the type and used for validation. Also the type can be contained in a dictionary and software could decide to retrieve this and use it for validation.
     </h:p>
    </h:div>
    <h:div class="example" href="scalar1.xml"/>
   </xsd:documentation>
  </xsd:annotation>
  <xsd:complexType>
   <xsd:simpleContent>
    <xsd:extension base="xsd:string">
     <xsd:attributeGroup ref="title"/>
     <xsd:attributeGroup ref="id"/>
     <xsd:attributeGroup ref="convention"/>
     <xsd:attributeGroup ref="dictRef"/>
     <xsd:attributeGroup ref="dataType"/>
     <xsd:attributeGroup ref="errorValue"/>
     <xsd:attributeGroup ref="errorBasis"/>
     <xsd:attributeGroup ref="min"/>
     <xsd:attributeGroup ref="max"/>
     <xsd:attributeGroup ref="ref"/>
     <xsd:attributeGroup ref="units"/>
     <xsd:attributeGroup ref="constantToSI">
      <xsd:annotation>
       <xsd:documentation>
        <h:div class="specific">Alternative to units</h:div>
        <h:div class="description">Must be used in conjunction with unitType</h:div>
        <h:div class="curation">2005-10-26: added</h:div>
       </xsd:documentation>
      </xsd:annotation>
     </xsd:attributeGroup>
     <xsd:attributeGroup ref="multiplierToSI">
      <xsd:annotation>
       <xsd:documentation>
        <h:div class="specific">Alternative to units</h:div>
        <h:div class="description">Must be used in conjunction with unitType</h:div>
        <h:div class="curation">2005-10-26: added</h:div>
       </xsd:documentation>
      </xsd:annotation>
     </xsd:attributeGroup>
     <xsd:attributeGroup ref="unitType">
      <xsd:annotation>
       <xsd:documentation>
        <h:div class="specific">Alternative to units</h:div>
        <h:div class="description">Must be used in conjunction with multiplierToSI and/or constantToSI</h:div>
        <h:div class="curation">2005-10-26: added</h:div>
       </xsd:documentation>
      </xsd:annotation>
     </xsd:attributeGroup>
    </xsd:extension>
   </xsd:simpleContent>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="spectator" id="el.spectator" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">A spectator object in a reaction.</h:div>
    <h:div class="description">Objects are often present during a reaction which are not formally involved in bond breaking/formation and which are not modified during the reaction. They may be catalysts, but may also be objects which in some way constrain or help the reaction to take place (surfaces, micelles, groups in enzyme active sites, etc.). In some cases molecules present in a reaction mixture may act as spectators in steps in which they are not transformed.</h:div>
    <h:div class="example" href="spectator1.xml"/>
   </xsd:documentation>
  </xsd:annotation>
  <xsd:complexType>
   <xsd:sequence>
    <xsd:element ref="metadataList" minOccurs="0" maxOccurs="unbounded"/>
    <xsd:choice minOccurs="0" maxOccurs="unbounded">
     <xsd:element ref="label"/>
     <xsd:element ref="molecule"/>
     <xsd:element ref="object"/>
    </xsd:choice>
   </xsd:sequence>
   <xsd:attributeGroup ref="title"/>
   <xsd:attributeGroup ref="id"/>
   <xsd:attributeGroup ref="convention"/>
   <xsd:attributeGroup ref="dictRef"/>
   <xsd:attributeGroup ref="role">
    <xsd:annotation>
     <xsd:documentation>
      <h:div class="specific">No controlled vocabulary. Examples could be 'host', 'hydrophobic ligand', 'charge-stabilizer', etc..</h:div>
     </xsd:documentation>
    </xsd:annotation>
   </xsd:attributeGroup>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="spectatorList" id="el.spectatorList" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">A container for spectators in a reaction.</h:div>
    <h:div class="description"/>
    <h:div class="example" href="spectatorList1.xml"/>
   </xsd:documentation>
  </xsd:annotation>
  <xsd:complexType>
   <xsd:sequence maxOccurs="unbounded">
    <xsd:element ref="spectator"/>
   </xsd:sequence>
   <xsd:attributeGroup ref="title"/>
   <xsd:attributeGroup ref="id"/>
   <xsd:attributeGroup ref="convention"/>
   <xsd:attributeGroup ref="dictRef"/>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="spectrum" id="el.spectrum" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">A spectrum and relevant data or metadata.</h:div>
    <h:div class="description">The 
     <h:tt>spectrum</h:tt> construct can hold 
     <h:tt>metadataList</h:tt>, 
     <h:tt>sample</h:tt> (which can contain molecule), 
     <h:tt>conditionList</h:tt> (mainly for physical/chemical conditions, not instrumental), 
     <h:tt>spectrumData</h:tt> for the actual data and instrumental settings/procedure and 
     <h:tt>peakList</h:tt> for the assigned peaks. This approach puts the spectrum as the primary object of interest. It could also be possible to make 
     <h:tt>spectrum</h:tt> a child of 
     <h:tt>molecule</h:tt> (although a reference using 
     <h:tt>ref</h:tt> might be preferable).
    </h:div>
    <h:div class="example" href="spectrum1.xml"/>
   </xsd:documentation>
  </xsd:annotation>
  <xsd:complexType>
   <xsd:choice minOccurs="0" maxOccurs="unbounded">
    <xsd:element ref="metadataList" minOccurs="0" maxOccurs="unbounded"/>
    <xsd:element ref="sample" minOccurs="0" maxOccurs="unbounded">
     <xsd:annotation>
      <xsd:documentation>
       <h:div>A (complete) description of the thing to which the spectrum relates. May contain 
        <h:tt>molecule</h:tt> or 
        <h:tt>substanceList</h:tt>. Solvents, mulls, etc should be described here.
       </h:div>
      </xsd:documentation>
     </xsd:annotation>
    </xsd:element>
    <xsd:element ref="parameterList" minOccurs="0" maxOccurs="unbounded"/>
    <xsd:element ref="substanceList" minOccurs="0" maxOccurs="unbounded"/>
    <xsd:element ref="conditionList" minOccurs="0" maxOccurs="unbounded">
     <xsd:annotation>
      <xsd:documentation>
       <h:div>The conditions relating to the spectrum (complementary to substanceList.</h:div>
      </xsd:documentation>
     </xsd:annotation>
    </xsd:element>
    <xsd:element ref="spectrumData" minOccurs="0" maxOccurs="unbounded"/>
    <xsd:element ref="peakList" minOccurs="0" maxOccurs="unbounded">
     <xsd:annotation>
      <xsd:documentation>
       <h:div>A list of peaks. This may occur independently of the xaxis/yaxis data.</h:div>
      </xsd:documentation>
     </xsd:annotation>
    </xsd:element>
   </xsd:choice>
   <xsd:attributeGroup ref="dictRef"/>
   <xsd:attributeGroup ref="convention"/>
   <xsd:attributeGroup ref="title"/>
   <xsd:attributeGroup ref="id"/>
   <xsd:attributeGroup ref="ref"/>
   <xsd:attributeGroup ref="moleculeRef">
    <xsd:annotation>
     <xsd:documentation>
      <h:div class="specific">The molecule to which the spectrum refers.</h:div>
     </xsd:documentation>
    </xsd:annotation>
   </xsd:attributeGroup>
   <xsd:attributeGroup ref="spectrumType"/>
   <xsd:attributeGroup ref="format"/>
   <xsd:attributeGroup ref="measurement"/>
   <xsd:attributeGroup ref="ft"/>
   <xsd:attributeGroup ref="state">
    <xsd:annotation>
     <xsd:documentation>
      <h:div class="specific">Although this may also be contained in the 
       <h:tt>sample</h:tt> element it is useful to state it here. No default.
      </h:div>
     </xsd:documentation>
    </xsd:annotation>
   </xsd:attributeGroup>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="spectrumData" id="el.spectrumData" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">Data for the spectrum.</h:div>
    <h:div class="description">This is primarily to record the data in interchangeable format and machine and manufacturers settings and can include other MLs in this area (AniML, SpectroML, etc.). We recommend ASCII representations of data and this is the only format that CMLSpect implementers have to support, but we also allow for the carriage of JCAMP and other data (in ML wrappers such as AniML). All numeric data should carry units and dictionary references if possible to allow for semantic interoperability.</h:div>
    <h:div class="example" href="spectrumData1.xml"/>
   </xsd:documentation>
  </xsd:annotation>
  <xsd:complexType>
   <xsd:sequence>
    <xsd:sequence minOccurs="0" maxOccurs="1">
     <xsd:element ref="xaxis">
      <xsd:annotation>
       <xsd:documentation>
        <h:div>The x-axis/es, usually including the list of points at which data are recorded. Mandatory if y-axis data are given. Multiple x-axes are initially reserved for multiple scales rather than different measurements (for which an additional spectrum should be used).</h:div>
       </xsd:documentation>
      </xsd:annotation>
     </xsd:element>
     <xsd:element ref="yaxis" maxOccurs="unbounded">
      <xsd:annotation>
       <xsd:documentation>
        <h:div>The y-axis/es, usually including the list of points at which data are recorded. Mandatory if x-axis data are given. Multiple y-axes are initially reserved for multiple scales rather than different measurements (for which an additional spectrum should be used).</h:div>
       </xsd:documentation>
      </xsd:annotation>
     </xsd:element>
    </xsd:sequence>
   </xsd:sequence>
   <xsd:attributeGroup ref="dictRef"/>
   <xsd:attributeGroup ref="convention"/>
   <xsd:attributeGroup ref="title"/>
   <xsd:attributeGroup ref="id"/>
   <xsd:attributeGroup ref="ref"/>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="spectrumList" id="el.spectrumList" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">A container for one or more spectra.</h:div>
    <h:div class="description">
     <h:p>
      <h:tt>spectrumList</h:tt> can contain several spectra. These may be related in several ways, including 
      <h:ul>
       <h:li>lists of related spectra</h:li>
       <h:li>bundle of common analytical spectra (NMR, IR, UV...)</h:li>
       <h:li>repeat measurements</h:li>
      </h:ul>. A spectrumList can contain nested spectrumLists. 
     </h:p>
    </h:div>
    <h:div class="example" href="spectrumList1.xml"/>
   </xsd:documentation>
  </xsd:annotation>
  <xsd:complexType>
   <xsd:annotation>
    <xsd:documentation>
     <h:div>
      <h:tt>metadataList</h:tt> contains 
      <h:tt>metadata</h:tt>. 
      <h:tt>list</h:tt> is for experimental and other data. 
      <h:tt>spectrumList</h:tt> normally contains 
      <h:tt>spectrum</h:tt>s but we make provision for nested spectrumLists if required. The 
      <h:tt>molecule</h:tt>s can be a set of reference molecules which occur in the 
      <h:tt>spectrum</h:tt>s and can be referenced. This makes the spectrums more readable and normalizes data when molecules are used more than once.
     </h:div>
    </xsd:documentation>
   </xsd:annotation>
   <xsd:sequence>
    <xsd:element ref="metadataList" minOccurs="0" maxOccurs="unbounded"/>
    <xsd:element ref="list" minOccurs="0" maxOccurs="unbounded"/>
    <xsd:choice>
     <xsd:element ref="spectrumList" minOccurs="0" maxOccurs="unbounded"/>
     <xsd:element ref="spectrum" minOccurs="0" maxOccurs="unbounded"/>
    </xsd:choice>
   </xsd:sequence>
   <xsd:attributeGroup ref="dictRef"/>
   <xsd:attributeGroup ref="convention"/>
   <xsd:attributeGroup ref="title"/>
   <xsd:attributeGroup ref="id"/>
   <xsd:attributeGroup ref="ref"/>
   <xsd:attributeGroup ref="moleculeRef"/>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="sphere3" id="el.sphere3" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">A sphere in 3-space.</h:div>
    <h:div class="description"/>
   </xsd:documentation>
  </xsd:annotation>
  <xsd:complexType>
   <xsd:simpleContent>
    <xsd:extension base="sphere3Type">
     <xsd:attributeGroup ref="convention"/>
     <xsd:attributeGroup ref="dictRef"/>
     <xsd:attributeGroup ref="id"/>
     <xsd:attributeGroup ref="title"/>
     <xsd:attributeGroup ref="units"/>
    </xsd:extension>
   </xsd:simpleContent>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="stmml" id="el.stmml" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">An element to hold stmml data.</h:div>
    <h:div class="description">
     <h:tt>stmml</h:tt> holds stmml data under a single generic container. Other namespaces may be present as children. No semantics implied.
    </h:div>
    <h:div class="example" href="stmml1.xml"/>
    <!-- <h:div class="example" href="bad.stmml.xml"> <h:p>Note attribute (mistake) not in schema</h:p></h:div> <h:div class="example" href="bad.stmml2.xml"> <h:p>Note bad name</h:p></h:div> -->
   </xsd:documentation>
  </xsd:annotation>
  <xsd:complexType>
   <xsd:sequence minOccurs="0" maxOccurs="unbounded">
    <xsd:any processContents="lax"/>
   </xsd:sequence>
   <xsd:attributeGroup ref="title"/>
   <xsd:attributeGroup ref="id"/>
   <xsd:attributeGroup ref="convention"/>
   <xsd:attributeGroup ref="dictRef"/>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="string" id="el.string" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">CML-1 dataType (DEPRECATED).</h:div>
    <h:div class="description"/>
    <h:div class="example" href="../../examples/cmlone.xml"/>
   </xsd:documentation>
  </xsd:annotation>
  <xsd:complexType>
   <xsd:simpleContent>
    <xsd:extension base="xsd:string">
     <xsd:attributeGroup ref="builtin"/>
     <xsd:attributeGroup ref="convention"/>
     <xsd:attributeGroup ref="dictRef"/>
     <xsd:attributeGroup ref="id"/>
     <xsd:attributeGroup ref="title"/>
    </xsd:extension>
   </xsd:simpleContent>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="stringArray" id="el.stringArray" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">CML-1 dataType DEPRECATED.</h:div>
    <h:div class="description"/>
    <h:div class="example" href="../../examples/cmlone.xml"/>
   </xsd:documentation>
  </xsd:annotation>
  <xsd:complexType>
   <xsd:simpleContent>
    <xsd:extension base="xsd:string">
     <xsd:attributeGroup ref="builtin"/>
     <xsd:attributeGroup ref="convention"/>
     <xsd:attributeGroup ref="dictRef"/>
     <xsd:attributeGroup ref="id"/>
     <xsd:attributeGroup ref="title"/>
     <xsd:attributeGroup ref="min"/>
     <xsd:attributeGroup ref="max"/>
     <xsd:attributeGroup ref="size"/>
     <xsd:attributeGroup ref="delimiter"/>
    </xsd:extension>
   </xsd:simpleContent>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="substance" id="el.substance" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">A chemical substance.</h:div>
    <h:div class="description">
     <h:tt>substance</h:tt> represents a 
     <h:i>chemical substance</h:i> which is deliberately very general. It can represent things that may or may not be molecules, can and cannot be stored in bottles and may or may not be microscopic. Solutions and mixtures can be described by _substanceList_s of substances. The 
     <h:tt>type</h:tt> attribute can be used to give qualitative information characterising the substance ("granular", "90%", etc.) and _role_ to describe the role in process ("desiccant", "support", etc.). There is currently no controlled vocabulary. Note that 
     <h:tt>reaction</h:tt> is likely to have more precise semantics. The amount of a substance is controlled by the optional _amount_ child.
    </h:div>
    <h:div class="example" href="substance1.xml"/>
   </xsd:documentation>
   <xsd:documentation>
    <h:div class="curation">
     <h:p>Added property as a child 2002-12-29</h:p>
    </h:div>
   </xsd:documentation>
  </xsd:annotation>
  <xsd:complexType>
   <xsd:sequence>
    <xsd:element ref="metadataList" minOccurs="0" maxOccurs="unbounded"/>
    <xsd:element ref="amount" minOccurs="0"/>
    <xsd:choice>
     <xsd:element ref="molecule" minOccurs="0" maxOccurs="unbounded"/>
     <xsd:element ref="name" minOccurs="0" maxOccurs="unbounded"/>
     <xsd:element ref="property" minOccurs="0" maxOccurs="unbounded"/>
    </xsd:choice>
   </xsd:sequence>
   <xsd:attributeGroup ref="dictRef"/>
   <xsd:attributeGroup ref="convention"/>
   <xsd:attributeGroup ref="title"/>
   <xsd:attributeGroup ref="id"/>
   <xsd:attributeGroup ref="type"/>
   <xsd:attributeGroup ref="role">
    <xsd:annotation>
     <xsd:documentation>
      <h:div class="specific">
       <h:tt>role</h:tt> depends on context, and indicates some purpose associated with the substance. It might indicate 'catalyst', 'solvent', 'antoxidant', etc. but is not limited to any vocabulary.
      </h:div>
     </xsd:documentation>
    </xsd:annotation>
   </xsd:attributeGroup>
   <xsd:attributeGroup ref="ref"/>
   <xsd:attributeGroup ref="count"/>
   <xsd:attributeGroup ref="state"/>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="substanceList" id="el.substanceList" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">A list of chemical substances.</h:div>
    <h:div class="description">Deliberately very general - see substance. substanceList is designed to manage solutions, mixtures, etc. and there is a small enumerated controlled vocabulary, but this can be extended through dictionaries. 
     <h:p>substanceList can have an amount child. This can indicate the amount of a solution or mixture; this example describes 100 ml of 0.1M NaOH(aq). Although apparently longwinded it is precise and fully machine-interpretable</h:p>
    </h:div>
    <h:div class="curation">Added role attribute, 2003-03-12.</h:div>
    <h:div class="example" href="substanceList1.xml"/>
   </xsd:documentation>
  </xsd:annotation>
  <xsd:complexType>
   <xsd:sequence>
    <xsd:element ref="metadataList" minOccurs="0" maxOccurs="unbounded"/>
    <xsd:element ref="amount" minOccurs="0"/>
    <!-- <xsd:choice>-->
    <xsd:element ref="substance" minOccurs="0" maxOccurs="unbounded"/>
    <!-- PMR 2003-01-26 <xsd:sequence> <xsd:element ref="scalar" minOccurs="0" maxOccurs="unbounded"/> <xsd:element ref="array" minOccurs="0" maxOccurs="unbounded"/> <xsd:element ref="matrix" minOccurs="0" maxOccurs="unbounded"/> <xsd:element ref="list" minOccurs="0" maxOccurs="unbounded"/> </xsd:sequence> -->
    <xsd:element ref="propertyList" minOccurs="0"/>
    <!-- </xsd:choice>-->
   </xsd:sequence>
   <xsd:attributeGroup ref="dictRef"/>
   <xsd:attributeGroup ref="convention"/>
   <xsd:attributeGroup ref="title"/>
   <xsd:attributeGroup ref="id"/>
   <xsd:attributeGroup ref="substanceListType"/>
   <xsd:attributeGroup ref="role"/>
   <xsd:attributeGroup ref="ref"/>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="symmetry" id="el.symmetry" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">Molecular, crystallographic or other symmetry.</h:div>
    <h:div class="description">
     <h:p>
      <h:tt>symmetry</h:tt> provides a label and/or symmetry operations for molecules or crystals. Point and spacegroups can be specified by strings, though these are not enumerated, because of variability in syntax (spaces, case-sensitivity, etc.), potential high symmetries (e.g. TMV disk is D17) and non-standard spacegroup settings. Provision is made for explicit symmetry operations through &lt;matrix&gt; child elements.
     </h:p>
     <h:p>By default the axes of symmetry are defined by the symbol - thus C2v requires z to be the unique axis, while P21/c requires b/y. Spacegroups imply the semantics defined in International Tables for Crystallography, (Int Union for Cryst., Munksgaard). Point groups are also defined therein. </h:p>
     <h:p>The element may also be used to give a label for the symmetry species (irreducible representation) such as "A1u" for a vibration or orbital. </h:p>
     <h:p>The matrices should be 3x3 for point group operators and 3x4 for spacegroup operators. The use of crystallographic notation ("x,1/2+y,-z") is not supported - this would be &lt;matrix&gt;1 0 0 0.0 0 1 0 0.5 0 0 1 0.0&lt;matrix&gt;.</h:p>
     <h:p>The default convention for point group symmetry is 
      <h:tt>Schoenflies</h:tt> and for spacegroups is "H-M". Other conventions (e.g. "Hall") must be specfied through the 
      <h:tt>convention</h:tt> attribute.
     </h:p>
     <h:p>This element implies that the Cartesians or fractional coordinates in a molecule are oriented appropriately. In some cases it may be useful to specify the symmetry of an arbitarily oriented molecule and the &lt;molecule&gt; element has the attribute 
      <h:tt>symmetryOriented</h:tt> for this purpose.
     </h:p>
     <h:p>It may be better to use transform3 to hold the symmetry as they have fixed shape and have better defined mathematical operators.</h:p>
    </h:div>
    <h:div class="example" href="symmetry1.xml"/>
    <h:div class="curation">2005-11-03 PMR. Added transform3 as children. </h:div>
   </xsd:documentation>
  </xsd:annotation>
  <xsd:complexType>
   <xsd:sequence>
    <xsd:element ref="matrix" minOccurs="0" maxOccurs="unbounded"/>
    <xsd:element ref="transform3" minOccurs="0" maxOccurs="unbounded"/>
   </xsd:sequence>
   <xsd:attributeGroup ref="dictRef"/>
   <xsd:attributeGroup ref="convention"/>
   <xsd:attributeGroup ref="title"/>
   <xsd:attributeGroup ref="id"/>
   <xsd:attributeGroup ref="pointGroup"/>
   <xsd:attributeGroup ref="spaceGroup"/>
   <xsd:attributeGroup ref="irreducibleRepresentation"/>
   <xsd:attributeGroup ref="number">
    <xsd:annotation>
     <xsd:documentation>
      <h:div class="specific">The rotational symmetry number. Used for calculation of entropy, etc.</h:div>
     </xsd:documentation>
    </xsd:annotation>
   </xsd:attributeGroup>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="system" id="el.system" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">The complete system of components in a calculation.</h:div>
    <h:div class="description">There is no controlled vocabulary.</h:div>
   </xsd:documentation>
  </xsd:annotation>
  <xsd:complexType>
   <xsd:sequence>
    <xsd:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
   </xsd:sequence>
   <xsd:attributeGroup ref="dimensionality"/>
   <xsd:attributeGroup ref="periodicity"/>
   <xsd:attributeGroup ref="title"/>
   <xsd:attributeGroup ref="id"/>
   <xsd:attributeGroup ref="convention"/>
   <xsd:attributeGroup ref="dictRef"/>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="table" id="el.table" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">A rectangular table of any quantities.</h:div>
    <h:div class="description">
     <h:p>By default 
      <h:tt>table</h:tt> represents a rectangular table of any simple quantities representable as XSD or CML dataTypes. There are three layouts, columnwise, rowwise and without markup. In all cases it is essential that the columns, whether explicit or otherwise, are homogeneous within the column. Also the metadata for each column must be given explicitly. 
      <ul xmlns="">
       <li>columns: There is a single 
        <h:a href="el.arrayList">arrayList</h:a> child containing (homogeneous) child elements (
        <h:a href="el.array">array</h:a> or 
        <h:a href="el.list">list</h:a>of size 
        <h:tt>rows</h:tt> data. This is the "normal" orientation of data tables but the table display could be transposed by XSLT transformation if required. Access is to columns, and thence to the data within them. DataTyping, delimiters, etc are delegated to the arrays or lists, which must all be of the same size. 
       </li>
       <li>rows: with explicit 
        <tt>trow</tt>s. The metadata is carried in a 
        <tt>theader</tt> element of size 
        <tt>cols</tt>. Within each trow the data are contained in tcells
       </li>
       <li>content: The metadata is carried in a 
        <tt>theader</tt> element of size 
        <tt>cols</tt>. data are contained in a single 
        <tt>tableContent</tt> with columns moving fastest. Within the content the data are whitespace (or delimiter) separated.
       </li>
      </ul> For verification it is recommended that tables carry 
      <h:tt>rows</h:tt> and 
      <h:tt>columns</h:tt> attributes. The type of the tables should also be carried in a 
      <tt xmlns="">tableType</tt>attribute&gt; 
     </h:p>
    </h:div>
    <h:div>Validity contraints (XPath expression in table context) 
     <h:table>
      <h:tr>
       <h:th>type</h:th>
       <h:th>@tableType</h:th>
       <h:th>@rows</h:th>
       <h:th>actual rowCount</h:th>
       <h:th>@columns</h:th>
       <h:th>actual columnCount</h:th>
       <h:th>tableHeader</h:th>
       <h:th>arrayList</h:th>
       <h:th>tableRowList</h:th>
       <h:th>tableContent</h:th>
      </h:tr>
      <h:tr>
       <h:td>column based</h:td>
       <h:td>columnBased</h:td>
       <h:td>recommended</h:td>
       <h:td>./arrayList/@size or arrayList/*[self::array or self::list]/@size</h:td>
       <h:td>optional</h:td>
       <h:td>./arrayList/@size or count(arrayList/*[self::array or self::list])</h:td>
       <h:td>forbidden</h:td>
       <h:td>required</h:td>
       <h:td>forbidden</h:td>
       <h:td>forbidden</h:td>
      </h:tr>
      <h:tr>
       <h:td>row based</h:td>
       <h:td>rowBased</h:td>
       <h:td>recommended</h:td>
       <h:td>./tableRowList/@size or count(tableRowList/tableRow)</h:td>
       <h:td>recommended</h:td>
       <h:td>count(tableHeader/tableHeaderCell) or count(tableRowList/tableRow/tableCell)</h:td>
       <h:td>required</h:td>
       <h:td>forbidden</h:td>
       <h:td>required</h:td>
       <h:td>forbidden</h:td>
      </h:tr>
      <h:tr>
       <h:td>content based</h:td>
       <h:td>contentBased</h:td>
       <h:td>required</h:td>
       <h:td>only by analysing tde table</h:td>
       <h:td>recommended</h:td>
       <h:td>count(tableHeader/tableHeaderCell)</h:td>
       <h:td>required</h:td>
       <h:td>forbidden</h:td>
       <h:td>forbidden</h:td>
       <h:td>required</h:td>
      </h:tr>
     </h:table>
    </h:div>
    <h:div class="example" href="table1.xml"/>
    <h:div class="example" href="table2.xml"/>
    <h:div class="example" href="table3.xml"/>
   </xsd:documentation>
  </xsd:annotation>
  <xsd:complexType>
   <xsd:sequence>
    <xsd:choice>
     <!-- columnwise arrays -->
     <xsd:element ref="arrayList" minOccurs="0" maxOccurs="1"/>
     <!-- OR header, followed by rows or content -->
     <xsd:sequence>
      <xsd:element ref="tableHeader" minOccurs="1" maxOccurs="1"/>
      <xsd:choice>
       <!-- rowwise rows -->
       <xsd:element ref="tableRowList" minOccurs="0" maxOccurs="unbounded"/>
       <!-- unmarked content -->
       <xsd:element ref="tableContent" minOccurs="0" maxOccurs="1"/>
      </xsd:choice>
     </xsd:sequence>
    </xsd:choice>
   </xsd:sequence>
   <xsd:attributeGroup ref="rows"/>
   <xsd:attributeGroup ref="columns"/>
   <xsd:attributeGroup ref="units"/>
   <xsd:attributeGroup ref="tableType"/>
   <!-- <xsd:attributeGroup ref="dataType"/> -->
   <xsd:attributeGroup ref="title"/>
   <xsd:attributeGroup ref="id"/>
   <xsd:attributeGroup ref="convention"/>
   <xsd:attributeGroup ref="dictRef"/>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="tableCell" id="el.tableCell" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">A cell in a row of a table.</h:div>
    <h:div class="description">tableCell is a data container of the table and only occurs as a child of tableRow. Normally it contains simpleContent, but may also contain a single child element (which could itself have complex or mixed content). However tableCell should NOT directly contain multiple children of any sort or mixed content. (It is declared as mixed content here to allow either text or element content, but not both.). The metadata for tableCells must be declared in a tableHeader/tableHeaderCell system</h:div>
    <h:div class="example" href="table5.xml"/>
    <h:div class="example" href="table6.xml"/>
    <h:div class="example" href="tabler.xml"/>
   </xsd:documentation>
  </xsd:annotation>
  <xsd:complexType mixed="true">
   <xsd:sequence minOccurs="1">
    <xsd:any processContents="lax" minOccurs="0"/>
   </xsd:sequence>
   <xsd:attributeGroup ref="title"/>
   <xsd:attributeGroup ref="id"/>
   <xsd:attributeGroup ref="convention"/>
   <xsd:attributeGroup ref="dictRef"/>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="tableContent" id="el.tableContent" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">Unmarked content of a table.</h:div>
    <h:div class="description">
     <h:p>This only occurs as simpleContent or a tableContent elements. It contains table/@rows * table/@columns items arranged rowwise (i.e. columns is fastest moving). Metadata for columns must be defined in tableHeader. The items of the table are ASCII strings. They can be separated by whitespace or by a defined single character delimiter as in 
      <h:tt>array</h:tt>. The data must be rectangular and each implicit column must have consistent semantics. It can be used to hold CSV-like data (indeed CSV data can be directly entered as long as there are no quoted commas in which cas a different delimiter (or the safer tableRowList) should be used. Unlike tableRowList or arrayList (both of which can hold ASCII strings or XML elements, tableContent can only hold strings. 
     </h:p>
    </h:div>
    <h:div class="example" href="table7.xml"/>
   </xsd:documentation>
  </xsd:annotation>
  <xsd:complexType>
   <xsd:simpleContent>
    <xsd:extension base="xsd:string">
     <xsd:attributeGroup ref="title"/>
     <xsd:attributeGroup ref="id"/>
     <xsd:attributeGroup ref="delimiter"/>
     <xsd:attributeGroup ref="convention"/>
     <xsd:attributeGroup ref="dictRef"/>
    </xsd:extension>
   </xsd:simpleContent>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="tableHeader" id="el.tableHeader" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">Header for a table.</h:div>
    <h:div class="description">
     <h:p>Used for rowBased or contentBased tables when it is mandatory. Contains the metadata as tableHeaderCells which should match the (implicit) columns in number and semantic type. It is forbidden for arrayList tables as each array/list contains the metadata.</h:p>
    </h:div>
    <h:div class="example" href="table6.xml"/>
    <h:div class="example" href="table7.xml"/>
   </xsd:documentation>
  </xsd:annotation>
  <xsd:complexType>
   <xsd:sequence>
    <xsd:element ref="tableHeaderCell" minOccurs="0" maxOccurs="unbounded"/>
   </xsd:sequence>
   <xsd:attributeGroup ref="title"/>
   <xsd:attributeGroup ref="id"/>
   <xsd:attributeGroup ref="convention"/>
   <xsd:attributeGroup ref="dictRef"/>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="tableHeaderCell" id="el.tableHeaderCell" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">Metadata for a column of a table.</h:div>
    <h:div class="description">Only used when in rowBased or contentBased tables, and then as a direct child of tableHeader. There must be as many tableHeaderCells as there are implicit columns in tableRowList or tableContent. These cells carry the metadata and/or semantics for each column. These are similar to the attributes in 
     <h:tt>array</h:tt> but without the lsist of minValue, errors etc. However they can (and should) carry all the units metadata.
    </h:div>
    <h:div class="example" href="table5.xml"/>
    <h:div class="example" href="table6.xml"/>
    <h:div class="example" href="tabler.xml"/>
   </xsd:documentation>
  </xsd:annotation>
  <xsd:complexType>
   <!-- empty -->
   <xsd:sequence minOccurs="0" maxOccurs="0"> </xsd:sequence>
   <xsd:attributeGroup ref="title"/>
   <xsd:attributeGroup ref="id"/>
   <xsd:attributeGroup ref="convention"/>
   <xsd:attributeGroup ref="dictRef"/>
   <xsd:attributeGroup ref="dataType"/>
   <xsd:attributeGroup ref="units"/>
   <xsd:attributeGroup ref="constantToSI">
    <xsd:annotation>
     <xsd:documentation>
      <h:div class="specific">Alternative to units</h:div>
      <h:div class="description">Must be used in conjunction with unitType</h:div>
      <h:div class="curation">2005-10-26: added</h:div>
     </xsd:documentation>
    </xsd:annotation>
   </xsd:attributeGroup>
   <xsd:attributeGroup ref="multiplierToSI">
    <xsd:annotation>
     <xsd:documentation>
      <h:div class="specific">Alternative to units</h:div>
      <h:div class="description">Must be used in conjunction with unitType</h:div>
      <h:div class="curation">2005-10-26: added</h:div>
     </xsd:documentation>
    </xsd:annotation>
   </xsd:attributeGroup>
   <xsd:attributeGroup ref="unitType">
    <xsd:annotation>
     <xsd:documentation>
      <h:div class="specific">Alternative to units</h:div>
      <h:div class="description">Must be used in conjunction with multiplierToSI and/or constantToSI</h:div>
      <h:div class="curation">2005-10-26: added</h:div>
     </xsd:documentation>
    </xsd:annotation>
   </xsd:attributeGroup>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="tableRow" id="el.tableRow" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">A row in a rowBased table.</h:div>
    <h:div class="description">A direct child of tableRowList containing tableCells. At present all tableRows in a tableRowList must have the same count of tableCells and their semantics must correspond to the tableHeader in the table. No cells can be omitted and there is no spanning of cells. There is no need for a size attribute as the count is simply 
     <h:tt> count(tableCell)</h:tt>. 
    </h:div>
    <h:div class="example" href="table5.xml"/>
    <h:div class="example" href="table6.xml"/>
    <h:div class="example" href="tabler.xml"/>
   </xsd:documentation>
  </xsd:annotation>
  <xsd:complexType>
   <xsd:sequence>
    <xsd:element ref="tableCell" minOccurs="0" maxOccurs="unbounded"/>
   </xsd:sequence>
   <xsd:attributeGroup ref="title"/>
   <xsd:attributeGroup ref="id"/>
   <xsd:attributeGroup ref="convention"/>
   <xsd:attributeGroup ref="dictRef"/>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="tableRowList" id="el.tableRowList" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">List of rows in rowBased table.</h:div>
    <h:div class="description">
     <h:p>Metadata for rows must be defined in tableHeader.</h:p>
    </h:div>
    <h:div class="example" href="table2.xml"/>
   </xsd:documentation>
  </xsd:annotation>
  <xsd:complexType>
   <xsd:sequence>
    <xsd:element ref="tableRow" minOccurs="0" maxOccurs="unbounded"/>
   </xsd:sequence>
   <xsd:attributeGroup ref="title"/>
   <xsd:attributeGroup ref="id"/>
   <xsd:attributeGroup ref="convention"/>
   <xsd:attributeGroup ref="dictRef"/>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="torsion" id="el.torsion" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">A torsion angle ("dihedral") between 4 distinct atoms.</h:div>
    <h:div class="description">
     <h:p>The atoms need not be formally bonded. It can be used for:</h:p>
     <h:ul>
      <h:li>Recording experimentally determined torsion angles (e.g. in a crystallographic paper).</h:li>
      <h:li>Providing the torsion component for internal coordinates (e.g. z-matrix).</h:li>
     </h:ul>
     <h:p>Note that the order of atoms is important.</h:p>
    </h:div>
    <h:div class="example" href="torsion1.xml"/>
    <h:div class="curation">2006-02-07: PMR. Fixed torsionAngleUnits</h:div>
   </xsd:documentation>
  </xsd:annotation>
  <xsd:complexType>
   <xsd:simpleContent>
    <xsd:extension base="torsionAngleType">
     <xsd:attributeGroup ref="title"/>
     <xsd:attributeGroup ref="id"/>
     <xsd:attributeGroup ref="convention"/>
     <xsd:attributeGroup ref="dictRef"/>
     <xsd:attributeGroup ref="atomRefs4"/>
     <xsd:attributeGroup ref="angleUnits"/>
     <xsd:attributeGroup ref="errorValue"/>
     <xsd:attributeGroup ref="errorBasis"/>
     <xsd:attributeGroup ref="min"/>
     <xsd:attributeGroup ref="max"/>
     <xsd:attributeGroup ref="ref"/>
    </xsd:extension>
   </xsd:simpleContent>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="transform3" id="el.transform3" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">A transform in 3-space.</h:div>
    <h:div class="description">A 3-D transform. Conventionally a 4x4 matrix.</h:div>
   </xsd:documentation>
  </xsd:annotation>
  <xsd:complexType>
   <xsd:simpleContent>
    <xsd:extension base="matrix44Type">
     <xsd:attributeGroup ref="convention"/>
     <xsd:attributeGroup ref="dictRef"/>
     <xsd:attributeGroup ref="id"/>
     <xsd:attributeGroup ref="title"/>
    </xsd:extension>
   </xsd:simpleContent>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="transitionState" id="el.transitionState" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">The transition state in a reaction.</h:div>
    <h:div class="description">
     <h:p>This will normally contain a 
      <h:tt>molecule</h:tt> which in its 2D representation will have partial bonds. These are yet to be formalized for the 
      <h:tt>molecule</h:tt> element.
     </h:p>
     <h:p>Although spectators may stabilise or otherwise interact with the transitionState they are not contained within it.</h:p>
     <h:p>A 
      <h:tt>propertyList</h:tt> is provided to capture transitionState properties.
     </h:p>
     <h:p>Still experimental.</h:p>
    </h:div>
    <h:div class="example" href="transitionState1.xml"/>
   </xsd:documentation>
  </xsd:annotation>
  <xsd:complexType>
   <xsd:sequence>
    <xsd:element ref="molecule"/>
    <xsd:element ref="propertyList" minOccurs="0"/>
   </xsd:sequence>
   <xsd:attributeGroup ref="title"/>
   <xsd:attributeGroup ref="id"/>
   <xsd:attributeGroup ref="convention"/>
   <xsd:attributeGroup ref="dictRef"/>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="unit" id="el.unit" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">A scientific unit.</h:div>
    <h:div class="description">
     <h:p>A scientific unit. Units are of the following types:</h:p>
     <h:ul>
      <h:li>SI Units. These may be one of the seven fundamental types (e.g. meter) or may be derived (e.g. joule). An SI unit is identifiable because it has no parentSI attribute and will have a unitType attribute. 2005-122-17 - this may be obsolete; PMR</h:li>
      <h:li>nonSI Units. These will normally have a parent SI unit (e.g. calorie has joule as an SI parent). </h:li>
      <h:li> Constructed units. These use a syntax of the form: 
       <h:pre> &lt;unit id="g.s-1" name="gram per second" unitType="myUnitType:massPerTime"&gt; &lt;unit units="units:g" power="1"/&gt; &lt;unit units="siUnits:s" power="-1"/&gt; &lt;/unit&gt; </h:pre> This defines a new unit (g.s-1) which is composed from two existing units (units:g and siUnits:s) to create a new unit. The conversion to SI is computed from the two child units and may be added as a 'multiplierToSI' attribute. Only siUnits or units with 'multiplierToSI' can be used as child units; 'constantToSI cannot be used yet. If the new unit points to a unitType then the dimension can be checked. Thus if the published dimension of massPerTime does not agree with mass.length-1 an error is throwable. Alternatively a new unitType can be added as a child. 
      </h:li>
     </h:ul>
     <h:p> The relationship of a unit to its SI parent is potentially complex and inconsistencies may arise. The following are available: 
      <h:ul>
       <h:li>parentSI. This points to the ID of a parent SI unit. If this ID is the same as the current unit the implication is that this is an SI unit. </h:li>
       <h:li>isSI. a boolean indicating whether the current unit is SI. </h:li>
       <h:li>multiplierToSI and constantToSI. If these are 1.0 and 0.0 (or missing) the implication is that this unit is SI. However this is fragile as units can be defined without these attributes and a unit could coincidentally have no numeric differences but not be an SI unit. </h:li>
      </h:ul>
     </h:p>
    </h:div>
    <h:div class="example" href="unit1.xml"/>
    <h:div class="curation">2003:04-09 Description or parentSI attribute enhanced.</h:div>
    <h:div class="curation">2006:03-21 Added metadata and metadataList to content.</h:div>
   </xsd:documentation>
   <xsd:appinfo>
    <!-- this will constrain link integrity to parents, etc. -->
   </xsd:appinfo>
  </xsd:annotation>
  <xsd:complexType>
   <xsd:choice minOccurs="0" maxOccurs="unbounded">
    <xsd:element ref="metadata"/>
    <xsd:element ref="metadataList"/>
    <xsd:element ref="description"/>
    <xsd:element ref="annotation"/>
    <xsd:element ref="definition" minOccurs="0" maxOccurs="1"/>
    <xsd:element ref="unit" minOccurs="0" maxOccurs="unbounded">
     <xsd:annotation>
      <xsd:documentation>
       <h:div class="summary">Child unit used to build new unit.</h:div>
       <h:div class="description">
        <h:p>These children must have 'units' and 'power' attributes.</h:p>
       </h:div>
      </xsd:documentation>
     </xsd:annotation>
    </xsd:element>
    <xsd:element ref="unitType" minOccurs="0" maxOccurs="1">
     <xsd:annotation>
      <xsd:documentation>
       <h:div class="summary">Child unitType describing type of new unit.</h:div>
       <h:div class="description">
        <h:p>This can be added by the author (in which case they are responsible for checking consistency) or calculated by the software from the child units.</h:p>
       </h:div>
      </xsd:documentation>
     </xsd:annotation>
    </xsd:element>
   </xsd:choice>
   <xsd:attributeGroup ref="id"/>
   <xsd:attributeGroup ref="units">
    <xsd:annotation>
     <xsd:documentation>
      <h:div class="summary">Reference to a unit.</h:div>
      <h:div class="description">
       <h:p>This is used for the identification of child units when new units are composed from existing ones. Athough the syntax looks unusual it takes advantage of the tools for resolving units. See above for syntax. </h:p>
      </h:div>
     </xsd:documentation>
    </xsd:annotation>
   </xsd:attributeGroup>
   <xsd:attributeGroup ref="title"/>
   <xsd:attributeGroup ref="abbreviation">
    <xsd:annotation>
     <xsd:documentation>
      <h:div class="summary">Abbreviation for the unit.</h:div>
      <h:div class="description">
       <h:p>This may be obsolete and symbol should be preferred.</h:p>
      </h:div>
     </xsd:documentation>
    </xsd:annotation>
   </xsd:attributeGroup>
   <xsd:attributeGroup ref="symbol">
    <xsd:annotation>
     <xsd:documentation>
      <h:div class="summary">Symbol for the unit.</h:div>
      <h:div class="description">
       <h:p>This may be used for typographical display but NOT for identification as there is considerable variation in use.</h:p>
      </h:div>
      <h:div class="curation">2006-01-29: PMR. Added attribute.</h:div>
     </xsd:documentation>
    </xsd:annotation>
   </xsd:attributeGroup>
   <xsd:attributeGroup ref="name"/>
   <xsd:attributeGroup ref="parentSI"/>
   <xsd:attributeGroup ref="isSI"/>
   <xsd:attributeGroup ref="unitType"/>
   <xsd:attributeGroup ref="multiplierToData"/>
   <xsd:attributeGroup ref="multiplierToSI"/>
   <xsd:attributeGroup ref="constantToSI"/>
   <xsd:attributeGroup ref="power">
    <xsd:annotation>
     <xsd:documentation>
      <h:div class="summary">Power of unit used to create new one.</h:div>
      <h:div class="description">
       <h:p>Only allowed on child units</h:p>
      </h:div>
     </xsd:documentation>
    </xsd:annotation>
   </xsd:attributeGroup>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="unitList" id="el.unitList" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">A container for several unit entries.</h:div>
    <h:div class="description">Usually forms the complete units dictionary (along with metadata). Note: this used to hold both units and unitTypes (though in separate files). This was unwieldy and unitTypeList has been created to hold unitTypes. Implementers are recommended to change any unitList/unitType to unitTypeList/unitType</h:div>
    <h:div class="example" href="unitList1.xml"/>
    <h:div class="curation">2005-12-15. PMR. added namespace and dictionaryPrefix.</h:div>
    <h:div class="curation">2005-12-17. PMR. added siNamespace .</h:div>
    <h:div class="curation">2006-01-28. PMR. deprecated use for holding unitType.</h:div>
   </xsd:documentation>
  </xsd:annotation>
  <xsd:complexType>
   <xsd:sequence>
    <xsd:element ref="metadataList" minOccurs="0" maxOccurs="unbounded"/>
    <xsd:element ref="unitType" minOccurs="0" maxOccurs="unbounded">
     <xsd:annotation>
      <xsd:documentation>
       <h:div class="deprecated">2006-01-28: PMR. use unitTypeList.</h:div>
      </xsd:documentation>
     </xsd:annotation>
    </xsd:element>
    <xsd:element ref="unit" minOccurs="0" maxOccurs="unbounded"/>
   </xsd:sequence>
   <xsd:attributeGroup ref="title"/>
   <xsd:attributeGroup ref="id"/>
   <xsd:attributeGroup ref="convention"/>
   <xsd:attributeGroup ref="dictRef"/>
   <xsd:attributeGroup ref="unitListType">
    <xsd:annotation>
     <xsd:documentation>
      <h:div class="deprecated">2006-01-28: PMR. use unitTypeList.</h:div>
     </xsd:documentation>
    </xsd:annotation>
   </xsd:attributeGroup>
   <xsd:attributeGroup ref="namespace"/>
   <xsd:attributeGroup ref="siNamespace"/>
   <xsd:attributeGroup ref="dictionaryPrefix"/>
   <xsd:attributeGroup ref="href">
    <xsd:annotation>
     <xsd:documentation>
      <h:div class="specific">Maps dictRef prefix to the location of a dictionary. This requires the prefix and the physical URI address to be contained within the same file. We can anticipate that better mechanisms will arise - perhaps through XMLCatalogs. At least it works at present.</h:div>
     </xsd:documentation>
    </xsd:annotation>
   </xsd:attributeGroup>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="unitType" id="el.unitType" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">The type of a scientific unit.</h:div>
    <h:div class="description">
     <h:p>Mandatory for SI Units, optional for nonSI units since they should be able to obtain this from their parent. For complex derived units without parents it may be useful.</h:p>
     <h:p>Used within a unitList</h:p>
     <h:p>Distinguish carefully from 
      <h:a href="st.unitsType">unitsType</h:a> which is primarily used for attributes describing the units that elements carry
     </h:p>
    </h:div>
    <!-- <h:div class="example" href="unit2.xml"></h:div> -->
    <h:div class="example" href="unitType1.xml"/>
    <!-- <h:div class="example" href="unitType2.xml"></h:div> -->
    <h:div class="curation">2006-02-06: PMR. Added preserve and symbol attributes.</h:div>
   </xsd:documentation>
  </xsd:annotation>
  <xsd:complexType>
   <xsd:choice minOccurs="0" maxOccurs="unbounded">
    <xsd:element ref="annotation"/>
    <xsd:element ref="dimension" minOccurs="0" maxOccurs="unbounded"/>
    <xsd:element ref="description" minOccurs="0" maxOccurs="unbounded"/>
    <xsd:element ref="definition" minOccurs="0" maxOccurs="1"/>
   </xsd:choice>
   <xsd:attributeGroup ref="id"/>
   <xsd:attributeGroup ref="name"/>
   <xsd:attributeGroup ref="title"/>
   <xsd:attributeGroup ref="parentSI"/>
   <xsd:attributeGroup ref="abbreviation"/>
   <xsd:attributeGroup ref="preserve"/>
   <xsd:attributeGroup ref="symbol"/>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="unitTypeList" id="el.unitTypeList" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">A container for several unitType entries.</h:div>
    <h:div class="description">Usually forms the complete unitTypes dictionary (along with metadata). Note: unitTypes used to be held under unitList, but this was complicated to implement and unitTypeList makes a clean separation. </h:div>
    <h:div class="example" href="unitTypeList1.xml"/>
    <h:div class="curation">2006-01-28. PMR. created.</h:div>
   </xsd:documentation>
  </xsd:annotation>
  <xsd:complexType>
   <xsd:sequence>
    <xsd:element ref="metadataList" minOccurs="0" maxOccurs="unbounded"/>
    <xsd:element ref="unitType" minOccurs="0" maxOccurs="unbounded"/>
   </xsd:sequence>
   <xsd:attributeGroup ref="title"/>
   <xsd:attributeGroup ref="id"/>
   <xsd:attributeGroup ref="convention"/>
   <xsd:attributeGroup ref="dictRef"/>
   <xsd:attributeGroup ref="namespace"/>
   <xsd:attributeGroup ref="siNamespace"/>
   <xsd:attributeGroup ref="dictionaryPrefix"/>
   <xsd:attributeGroup ref="href">
    <xsd:annotation>
     <xsd:documentation>
      <h:div class="specific">Maps dictRef prefix to the location of a dictionary. This requires the prefix and the physical URI address to be contained within the same file. We can anticipate that better mechanisms will arise - perhaps through XMLCatalogs. At least it works at present.</h:div>
     </xsd:documentation>
    </xsd:annotation>
   </xsd:attributeGroup>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="vector3" id="el.vector3" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">A vector in 3-space.</h:div>
    <h:div class="description">The vector may have magnitude but is not rooted on any points (use line3).</h:div>
   </xsd:documentation>
  </xsd:annotation>
  <xsd:complexType>
   <xsd:simpleContent>
    <xsd:extension base="vector3Type">
     <xsd:attributeGroup ref="convention"/>
     <xsd:attributeGroup ref="dictRef"/>
     <xsd:attributeGroup ref="id"/>
     <xsd:attributeGroup ref="title"/>
     <xsd:attributeGroup ref="units"/>
    </xsd:extension>
   </xsd:simpleContent>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="xaxis" id="el.xaxis" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">The x-axis.</h:div>
    <h:div class="description">A container for all information relating to the x-axis (including scales, offsets, etc.) and the data themselves (in an 
     <h:tt>array</h:tt>). Note: AniML uses "xValues" so avoid confusion with this.
    </h:div>
    <h:div class="example" href="xaxis1.xml"/>
   </xsd:documentation>
  </xsd:annotation>
  <xsd:complexType>
   <xsd:sequence>
    <xsd:element ref="array">
     <xsd:annotation>
      <xsd:documentation>
       <h:div>The x-data. These must match the y-data in number and order. There are tools to allow scaling and transformation (though unscaled data must be very carefully defined).</h:div>
      </xsd:documentation>
     </xsd:annotation>
    </xsd:element>
   </xsd:sequence>
   <xsd:attributeGroup ref="dictRef"/>
   <xsd:attributeGroup ref="convention"/>
   <xsd:attributeGroup ref="title"/>
   <xsd:attributeGroup ref="id"/>
   <xsd:attributeGroup ref="ref"/>
   <xsd:attributeGroup ref="multiplierToData"/>
   <xsd:attributeGroup ref="constantToData"/>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="yaxis" id="el.yaxis" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">The y-axis.</h:div>
    <h:div class="description">A container for all information relating to the y-axis (including scales, offsets, etc.) and the data themselves (in an 
     <h:tt>array</h:tt>).
    </h:div>
    <h:div class="example" href="yaxis1.xml"/>
   </xsd:documentation>
  </xsd:annotation>
  <xsd:complexType>
   <xsd:sequence>
    <xsd:element ref="array">
     <xsd:annotation>
      <xsd:documentation>
       <h:div>The y-data. These must match the x-data in number and order. There are tools to allow scaling and transformation (though unscaled data must be very carefully defined).</h:div>
      </xsd:documentation>
     </xsd:annotation>
    </xsd:element>
   </xsd:sequence>
   <xsd:attributeGroup ref="dictRef"/>
   <xsd:attributeGroup ref="convention"/>
   <xsd:attributeGroup ref="title"/>
   <xsd:attributeGroup ref="id"/>
   <xsd:attributeGroup ref="ref"/>
   <xsd:attributeGroup ref="multiplierToData"/>
   <xsd:attributeGroup ref="constantToData"/>
  </xsd:complexType>
 </xsd:element>
 <xsd:element name="zMatrix" id="el.zMatrix" xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
   <xsd:documentation>
    <h:div class="summary">A zMatrix.</h:div>
    <h:div class="description">A container for 
     <h:tt>length</h:tt>, 
     <h:tt>angle</h:tt> and 
     <h:tt>torsion</h:tt>, which must be arranged in the conventional zMatrix format.
    </h:div>
    <h:div class="example" href="zMatrix1.xml"/>
   </xsd:documentation>
  </xsd:annotation>
  <xsd:complexType>
   <xsd:sequence>
    <xsd:choice minOccurs="0" maxOccurs="unbounded">
     <xsd:element ref="length"/>
     <xsd:element ref="angle"/>
     <xsd:element ref="torsion"/>
    </xsd:choice>
   </xsd:sequence>
   <xsd:attributeGroup ref="title"/>
   <xsd:attributeGroup ref="id"/>
   <xsd:attributeGroup ref="convention"/>
   <xsd:attributeGroup ref="dictRef"/>
  </xsd:complexType>
 </xsd:element>
</schema>
